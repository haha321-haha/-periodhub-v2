// é›†æˆå·¥ä½œæµç³»ç»Ÿ - ç»Ÿä¸€çš„æ–‡ä»¶æ¢å¤å·¥ä½œæµorchestrator
// file: recovery-workspace/integrated-workflow-system.js

const fs = require('fs');
const path = require('path');
const { spawn, execSync } = require('child_process');

// å¯¼å…¥æ‰€æœ‰å·²å®Œæˆçš„ç³»ç»Ÿæ¨¡å—
const { LoggingReportingSystem } = require('./logging-reporting-system.js');

class IntegratedWorkflowSystem {
    constructor(config = {}) {
        this.config = {
            workspaceDir: config.workspaceDir || './recovery-workspace',
            targetDir: config.targetDir || '../recovered',
            mode: config.mode || 'interactive', // 'interactive', 'auto', 'batch'
            skipConfirmations: config.skipConfirmations || false,
            dryRun: config.dryRun || false,
            enableLogging: config.enableLogging !== false,
            logLevel: config.logLevel || 'INFO',
            autoExecute: config.autoExecute || false,
            ...config
        };

        // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
        this.logger = new LoggingReportingSystem({
            logDir: path.join(this.config.workspaceDir, 'logs'),
            logLevel: this.config.logLevel,
            enableFile: true,
            enableMetrics: true
        });

        this.workflow = {
            currentStep: 0,
            totalSteps: 10,
            results: {},
            errors: [],
            startTime: null,
            endTime: null
        };

        this.steps = this.defineWorkflowSteps();
    }

    defineWorkflowSteps() {
        return [
            {
                id: 'setup',
                name: 'ç¯å¢ƒè®¾ç½®å’ŒéªŒè¯',
                description: 'éªŒè¯å·¥ä½œç¯å¢ƒå’Œä¾èµ–',
                required: true,
                handler: this.setupEnvironment.bind(this)
            },
            {
                id: 'collect',
                name: 'æ–‡ä»¶æ”¶é›†å’ŒéªŒè¯',
                description: 'æ”¶é›†å’ŒéªŒè¯miscæ–‡ä»¶',
                required: true,
                handler: this.collectFiles.bind(this)
            },
            {
                id: 'analyze',
                name: 'å†…å®¹åˆ†æ',
                description: 'åˆ†ææ–‡ä»¶å†…å®¹å’Œç‰¹å¾',
                required: true,
                handler: this.analyzeContent.bind(this)
            },
            {
                id: 'classify',
                name: 'è‡ªåŠ¨åˆ†ç±»',
                description: 'åŸºäºåˆ†æç»“æœè‡ªåŠ¨åˆ†ç±»æ–‡ä»¶',
                required: true,
                handler: this.classifyFiles.bind(this)
            },
            {
                id: 'suggest',
                name: 'æ–‡ä»¶åå»ºè®®',
                description: 'ç”Ÿæˆæ™ºèƒ½æ–‡ä»¶åå»ºè®®',
                required: true,
                handler: this.generateSuggestions.bind(this)
            },
            {
                id: 'review',
                name: 'æ‰‹åŠ¨å®¡æŸ¥',
                description: 'å®¡æŸ¥ä½ç½®ä¿¡åº¦æ–‡ä»¶',
                required: false,
                handler: this.manualReview.bind(this)
            },
            {
                id: 'plan',
                name: 'æ¢å¤è®¡åˆ’',
                description: 'æ„å»ºå®‰å…¨æ¢å¤è®¡åˆ’',
                required: true,
                handler: this.buildRecoveryPlan.bind(this)
            },
            {
                id: 'execute',
                name: 'å®‰å…¨æ¢å¤',
                description: 'æ‰§è¡Œæ–‡ä»¶æ¢å¤æ“ä½œ',
                required: true,
                handler: this.executeRecovery.bind(this)
            },
            {
                id: 'verify',
                name: 'ç»“æœéªŒè¯',
                description: 'éªŒè¯æ¢å¤ç»“æœ',
                required: true,
                handler: this.verifyResults.bind(this)
            },
            {
                id: 'report',
                name: 'ç”ŸæˆæŠ¥å‘Š',
                description: 'ç”Ÿæˆæœ€ç»ˆæŠ¥å‘Šå’Œæ¸…ç†',
                required: true,
                handler: this.generateFinalReport.bind(this)
            }
        ];
    }

    // ä¸»è¦å·¥ä½œæµæ‰§è¡Œæ–¹æ³•
    async execute() {
        this.logger.info('workflow', 'Starting integrated recovery workflow', {
            mode: this.config.mode,
            dryRun: this.config.dryRun
        });

        this.workflow.startTime = new Date();

        try {
            // æ˜¾ç¤ºå·¥ä½œæµæ¦‚è§ˆ
            await this.displayWorkflowOverview();

            // æ‰§è¡Œæ¯ä¸ªæ­¥éª¤
            for (let i = 0; i < this.steps.length; i++) {
                this.workflow.currentStep = i;
                const step = this.steps[i];

                await this.executeStep(step);

                // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æƒ³è¦ä¸­æ–­
                if (this.config.mode === 'interactive' && !this.config.autoExecute) {
                    const shouldContinue = await this.promptContinue();
                    if (!shouldContinue) {
                        this.logger.info('workflow', 'Workflow interrupted by user');
                        break;
                    }
                }
            }

            this.workflow.endTime = new Date();
            await this.completeWorkflow();

        } catch (error) {
            this.logger.error('workflow', 'Workflow execution failed', { step: this.workflow.currentStep }, error);
            await this.handleWorkflowError(error);
            throw error;
        }
    }

    async displayWorkflowOverview() {
        console.log('\nğŸš€ æ–‡ä»¶æ¢å¤é›†æˆå·¥ä½œæµ');
        console.log('=' .repeat(50));
        console.log(`æ¨¡å¼: ${this.config.mode}`);
        console.log(`ç›®æ ‡ç›®å½•: ${this.config.targetDir}`);
        console.log(`å¹²è¿è¡Œ: ${this.config.dryRun ? 'æ˜¯' : 'å¦'}`);
        console.log('\nğŸ“‹ å·¥ä½œæµæ­¥éª¤:');

        this.steps.forEach((step, index) => {
            const status = step.required ? 'ğŸ”´ å¿…éœ€' : 'ğŸŸ¡ å¯é€‰';
            console.log(`  ${index + 1}. ${step.name} - ${status}`);
            console.log(`     ${step.description}`);
        });

        console.log('\nâš ï¸  æ³¨æ„: æ‰€æœ‰æ“ä½œéƒ½ä¼šè¢«è¯¦ç»†è®°å½•ï¼Œæ”¯æŒå›æ»š\n');

        if (this.config.mode === 'interactive' && !this.config.skipConfirmations) {
            await this.waitForUserConfirmation('å‡†å¤‡å¼€å§‹å·¥ä½œæµï¼Ÿ');
        }
    }

    async executeStep(step) {
        const stepTimer = this.logger.startTimer(`step_${step.id}`);
        
        console.log(`\n${'='.repeat(60)}`);
        console.log(`ğŸ”„ æ­¥éª¤ ${this.workflow.currentStep + 1}/${this.steps.length}: ${step.name}`);
        console.log(`ğŸ“ ${step.description}`);
        console.log(`${'='.repeat(60)}`);

        this.logger.logRecoveryStage(step.name, {
            stepId: step.id,
            stepIndex: this.workflow.currentStep,
            required: step.required
        });

        try {
            const result = await step.handler();
            this.workflow.results[step.id] = result;

            console.log(`âœ… æ­¥éª¤ ${step.name} å®Œæˆ`);
            this.logger.info('workflow', `Step ${step.id} completed successfully`, { result });

        } catch (error) {
            console.log(`âŒ æ­¥éª¤ ${step.name} å¤±è´¥: ${error.message}`);
            this.workflow.errors.push({
                step: step.id,
                error: error.message,
                timestamp: new Date()
            });

            if (step.required) {
                throw error;
            } else {
                this.logger.warn('workflow', `Optional step ${step.id} failed, continuing`, {}, error);
            }
        } finally {
            stepTimer.end();
        }
    }

    // æ­¥éª¤å®ç°
    async setupEnvironment() {
        this.logger.info('setup', 'Setting up environment');

        const checks = {
            workspaceExists: fs.existsSync(this.config.workspaceDir),
            analysisDir: fs.existsSync(path.join(this.config.workspaceDir, 'analysis')),
            targetDir: this.ensureDirectory(this.config.targetDir),
            nodeModules: this.checkNodeModules(),
            permissions: await this.checkPermissions()
        };

        console.log('ğŸ” ç¯å¢ƒæ£€æŸ¥:');
        Object.entries(checks).forEach(([check, result]) => {
            console.log(`   ${result ? 'âœ…' : 'âŒ'} ${check}: ${result ? 'é€šè¿‡' : 'å¤±è´¥'}`);
        });

        if (!checks.workspaceExists) {
            throw new Error('å·¥ä½œåŒºç›®å½•ä¸å­˜åœ¨ï¼Œè¯·å…ˆè¿è¡Œæ–‡ä»¶æ”¶é›†');
        }

        this.logger.recordMetric('environment_checks_passed', Object.values(checks).filter(Boolean).length);
        return checks;
    }

    async collectFiles() {
        this.logger.info('collect', 'Starting file collection');
        
        const analysisDir = path.join(this.config.workspaceDir, 'analysis');
        
        if (!fs.existsSync(analysisDir)) {
            throw new Error('åˆ†æç›®å½•ä¸å­˜åœ¨ï¼Œè¯·å…ˆè¿è¡Œæ–‡ä»¶æ”¶é›†');
        }

        const miscFiles = fs.readdirSync(analysisDir)
            .filter(f => f.startsWith('misc-') && (f.endsWith('.js') || f.endsWith('.jsx') || f.endsWith('.ts') || f.endsWith('.tsx')));

        console.log(`ğŸ“ å‘ç° ${miscFiles.length} ä¸ªmiscæ–‡ä»¶`);

        // éªŒè¯æ–‡ä»¶å®Œæ•´æ€§
        let validFiles = 0;
        for (const file of miscFiles) {
            try {
                const filePath = path.join(analysisDir, file);
                const stats = fs.statSync(filePath);
                if (stats.size > 0) {
                    validFiles++;
                }
            } catch (error) {
                this.logger.warn('collect', `File validation failed: ${file}`, {}, error);
            }
        }

        console.log(`âœ… ${validFiles} ä¸ªæ–‡ä»¶éªŒè¯é€šè¿‡`);
        
        this.logger.recordMetric('misc_files_found', miscFiles.length);
        this.logger.recordMetric('valid_files', validFiles);

        return {
            totalFiles: miscFiles.length,
            validFiles,
            files: miscFiles
        };
    }

    async analyzeContent() {
        this.logger.info('analyze', 'Starting content analysis');
        
        return await this.runNodeScript('advanced-analysis-engine.js', {
            description: 'å†…å®¹åˆ†æå¼•æ“',
            expectedOutput: 'reports/ultimate-analysis-report.json'
        });
    }

    async classifyFiles() {
        this.logger.info('classify', 'Starting file classification');
        
        return await this.runNodeScript('auto-file-classifier.js', {
            description: 'è‡ªåŠ¨æ–‡ä»¶åˆ†ç±»ç³»ç»Ÿ',
            expectedOutput: 'classification-report.json'
        });
    }

    async generateSuggestions() {
        this.logger.info('suggest', 'Generating filename suggestions');
        
        return await this.runNodeScript('filename-suggestion-engine.js', {
            description: 'æ–‡ä»¶åå»ºè®®å¼•æ“',
            expectedOutput: 'filename-suggestions-report.json'
        });
    }

    async manualReview() {
        this.logger.info('review', 'Starting manual review process');

        if (this.config.mode === 'auto') {
            console.log('â­ï¸  è‡ªåŠ¨æ¨¡å¼ï¼Œè·³è¿‡æ‰‹åŠ¨å®¡æŸ¥');
            return { skipped: true, reason: 'auto mode' };
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰éœ€è¦å®¡æŸ¥çš„æ–‡ä»¶
        const classifiedDir = path.join(this.config.workspaceDir, 'classified', 'manual-review');
        if (!fs.existsSync(classifiedDir)) {
            console.log('âœ… æ²¡æœ‰éœ€è¦æ‰‹åŠ¨å®¡æŸ¥çš„æ–‡ä»¶');
            return { required: false };
        }

        const reviewFiles = fs.readdirSync(classifiedDir);
        if (reviewFiles.length === 0) {
            console.log('âœ… æ²¡æœ‰éœ€è¦æ‰‹åŠ¨å®¡æŸ¥çš„æ–‡ä»¶');
            return { required: false };
        }

        console.log(`ğŸ“‹ å‘ç° ${reviewFiles.length} ä¸ªæ–‡ä»¶éœ€è¦æ‰‹åŠ¨å®¡æŸ¥`);

        if (this.config.mode === 'interactive') {
            const shouldReview = await this.promptYesNo('æ˜¯å¦ç°åœ¨è¿›è¡Œæ‰‹åŠ¨å®¡æŸ¥ï¼Ÿ');
            if (shouldReview) {
                return await this.runNodeScript('manual-review-interface.js', {
                    description: 'æ‰‹åŠ¨å®¡æŸ¥ç•Œé¢',
                    expectedOutput: 'manual-review-results.json',
                    interactive: true
                });
            }
        }

        return { deferred: true, fileCount: reviewFiles.length };
    }

    async buildRecoveryPlan() {
        this.logger.info('plan', 'Building recovery plan');
        
        return await this.runNodeScript('recovery-plan-builder.js', {
            description: 'æ¢å¤è®¡åˆ’æ„å»ºå™¨',
            expectedOutput: 'recovery-plan.json'
        });
    }

    async executeRecovery() {
        this.logger.info('execute', 'Executing recovery operations');

        if (this.config.dryRun) {
            console.log('ğŸ” DRY RUNæ¨¡å¼ - ä»…æ¨¡æ‹Ÿæ“ä½œ');
        }

        return await this.runNodeScript('safe-recovery-system.js', {
            description: 'å®‰å…¨æ¢å¤ç³»ç»Ÿ',
            expectedOutput: 'recovery-report.json',
            dryRun: this.config.dryRun
        });
    }

    async verifyResults() {
        this.logger.info('verify', 'Verifying recovery results');

        const recoveryReportPath = path.join(this.config.workspaceDir, 'recovery-report.json');
        if (!fs.existsSync(recoveryReportPath)) {
            throw new Error('æ¢å¤æŠ¥å‘Šä¸å­˜åœ¨ï¼Œæ— æ³•éªŒè¯ç»“æœ');
        }

        const recoveryReport = JSON.parse(fs.readFileSync(recoveryReportPath, 'utf8'));
        
        console.log('ğŸ“Š æ¢å¤ç»“æœéªŒè¯:');
        console.log(`   âœ… æˆåŠŸ: ${recoveryReport.summary.successful} ä¸ªæ–‡ä»¶`);
        console.log(`   âŒ å¤±è´¥: ${recoveryReport.summary.failed} ä¸ªæ–‡ä»¶`);
        console.log(`   ğŸ“ˆ æˆåŠŸç‡: ${((recoveryReport.summary.successful / recoveryReport.summary.totalOperations) * 100).toFixed(1)}%`);

        // éªŒè¯ç›®æ ‡ç›®å½•ä¸­çš„æ–‡ä»¶
        if (!this.config.dryRun) {
            const targetFiles = this.countFilesInDirectory(this.config.targetDir);
            console.log(`   ğŸ“ ç›®æ ‡ç›®å½•æ–‡ä»¶æ•°: ${targetFiles}`);
            
            this.logger.recordMetric('target_files_count', targetFiles);
        }

        this.logger.recordMetric('recovery_success_rate', 
            (recoveryReport.summary.successful / recoveryReport.summary.totalOperations) * 100);

        return {
            recoveryReport,
            verified: true,
            successRate: (recoveryReport.summary.successful / recoveryReport.summary.totalOperations) * 100
        };
    }

    async generateFinalReport() {
        this.logger.info('report', 'Generating final workflow report');

        const workflowReport = {
            workflow: {
                startTime: this.workflow.startTime,
                endTime: new Date(),
                duration: new Date() - this.workflow.startTime,
                totalSteps: this.steps.length,
                completedSteps: this.workflow.currentStep + 1,
                errors: this.workflow.errors
            },
            results: this.workflow.results,
            summary: this.generateWorkflowSummary()
        };

        // ä¿å­˜å·¥ä½œæµæŠ¥å‘Š
        const reportPath = path.join(this.config.workspaceDir, 'workflow-report.json');
        fs.writeFileSync(reportPath, JSON.stringify(workflowReport, null, 2));

        // ç”Ÿæˆäººç±»å¯è¯»çš„æŠ¥å‘Š
        await this.generateHumanReadableWorkflowReport(workflowReport);

        // ç”Ÿæˆæœ€ç»ˆçš„ç³»ç»ŸæŠ¥å‘Š
        await this.logger.generateReport('full');

        console.log('\nğŸ“„ ç”Ÿæˆçš„æŠ¥å‘Šæ–‡ä»¶:');
        console.log(`   ğŸ“Š å·¥ä½œæµæŠ¥å‘Š: ${reportPath}`);
        console.log(`   ğŸ“‹ è¯¦ç»†æ—¥å¿—: ${path.join(this.config.workspaceDir, 'logs')}`);

        return workflowReport;
    }

    generateWorkflowSummary() {
        const successful = Object.keys(this.workflow.results).length;
        const failed = this.workflow.errors.length;
        
        return {
            totalSteps: this.steps.length,
            successfulSteps: successful,
            failedSteps: failed,
            completionRate: (successful / this.steps.length) * 100,
            duration: this.workflow.endTime - this.workflow.startTime,
            recommendations: this.generateFinalRecommendations()
        };
    }

    generateFinalRecommendations() {
        const recommendations = [];
        
        if (this.workflow.errors.length === 0) {
            recommendations.push({
                priority: 'high',
                action: 'test_project',
                message: 'æ¢å¤å®Œæˆï¼å»ºè®®æµ‹è¯•é¡¹ç›®æ„å»ºå’Œè¿è¡Œ'
            });
        } else {
            recommendations.push({
                priority: 'high',
                action: 'review_errors',
                message: `éœ€è¦å¤„ç† ${this.workflow.errors.length} ä¸ªé”™è¯¯`
            });
        }

        const results = this.workflow.results;
        if (results.review && results.review.deferred) {
            recommendations.push({
                priority: 'medium',
                action: 'complete_review',
                message: 'å®Œæˆå»¶åçš„æ‰‹åŠ¨å®¡æŸ¥ä»»åŠ¡'
            });
        }

        return recommendations;
    }

    async generateHumanReadableWorkflowReport(report) {
        let markdown = '# ğŸš€ æ–‡ä»¶æ¢å¤å·¥ä½œæµå®Œæ•´æŠ¥å‘Š\n\n';
        
        markdown += `**å¼€å§‹æ—¶é—´**: ${report.workflow.startTime.toLocaleString()}\n`;
        markdown += `**ç»“æŸæ—¶é—´**: ${report.workflow.endTime.toLocaleString()}\n`;
        markdown += `**æ€»è€—æ—¶**: ${Math.round(report.workflow.duration / 1000)} ç§’\n\n`;

        markdown += '## ğŸ“Š å·¥ä½œæµç»Ÿè®¡\n';
        markdown += `- æ€»æ­¥éª¤æ•°: ${report.workflow.totalSteps}\n`;
        markdown += `- å®Œæˆæ­¥éª¤: ${report.workflow.completedSteps}\n`;
        markdown += `- æˆåŠŸç‡: ${report.summary.completionRate.toFixed(1)}%\n`;
        markdown += `- é”™è¯¯æ•°: ${report.workflow.errors.length}\n\n`;

        // æ­¥éª¤æ‰§è¡Œç»“æœ
        markdown += '## ğŸ“‹ æ­¥éª¤æ‰§è¡Œç»“æœ\n';
        this.steps.forEach((step, index) => {
            const result = report.results[step.id];
            const status = result ? 'âœ…' : (report.workflow.errors.find(e => e.step === step.id) ? 'âŒ' : 'â­ï¸');
            markdown += `${index + 1}. ${status} **${step.name}**: ${step.description}\n`;
        });
        markdown += '\n';

        // é”™è¯¯è¯¦æƒ…
        if (report.workflow.errors.length > 0) {
            markdown += '## âŒ é”™è¯¯è¯¦æƒ…\n';
            report.workflow.errors.forEach(error => {
                markdown += `- **${error.step}**: ${error.error}\n`;
            });
            markdown += '\n';
        }

        // æ¨èæ“ä½œ
        markdown += '## ğŸš€ æ¨èçš„åç»­æ“ä½œ\n';
        report.summary.recommendations.forEach((rec, i) => {
            const priority = rec.priority === 'high' ? 'ğŸ”¥' : rec.priority === 'medium' ? 'âš¡' : 'ğŸ“';
            markdown += `${i + 1}. ${priority} **${rec.action}**: ${rec.message}\n`;
        });

        const reportPath = path.join(this.config.workspaceDir, 'WORKFLOW_REPORT.md');
        fs.writeFileSync(reportPath, markdown);

        console.log(`ğŸ“‹ å·¥ä½œæµæŠ¥å‘Šå·²ç”Ÿæˆ: ${reportPath}`);
    }

    // è¾…åŠ©æ–¹æ³•
    async runNodeScript(scriptName, options = {}) {
        const scriptPath = path.join(this.config.workspaceDir, scriptName);
        
        if (!fs.existsSync(scriptPath)) {
            throw new Error(`è„šæœ¬æ–‡ä»¶ä¸å­˜åœ¨: ${scriptPath}`);
        }

        console.log(`ğŸ”„ è¿è¡Œ ${options.description || scriptName}...`);
        this.logger.info('script', `Executing script: ${scriptName}`, options);

        return new Promise((resolve, reject) => {
            const args = ['node', scriptPath];
            if (options.dryRun) {
                args.push('--dry-run');
            }

            const child = spawn(args[0], args.slice(1), {
                cwd: path.dirname(scriptPath),
                stdio: options.interactive ? 'inherit' : 'pipe'
            });

            let output = '';
            let errorOutput = '';

            if (!options.interactive) {
                child.stdout?.on('data', (data) => {
                    output += data.toString();
                    console.log(data.toString().trim());
                });

                child.stderr?.on('data', (data) => {
                    errorOutput += data.toString();
                    console.error(data.toString().trim());
                });
            }

            child.on('close', (code) => {
                if (code === 0) {
                    console.log(`âœ… ${options.description || scriptName} å®Œæˆ`);
                    
                    // æ£€æŸ¥é¢„æœŸçš„è¾“å‡ºæ–‡ä»¶
                    if (options.expectedOutput) {
                        const outputPath = path.join(this.config.workspaceDir, options.expectedOutput);
                        if (fs.existsSync(outputPath)) {
                            this.logger.info('script', `Output file created: ${options.expectedOutput}`);
                        } else {
                            this.logger.warn('script', `Expected output file not found: ${options.expectedOutput}`);
                        }
                    }

                    resolve({
                        success: true,
                        exitCode: code,
                        output,
                        script: scriptName
                    });
                } else {
                    const error = new Error(`è„šæœ¬æ‰§è¡Œå¤±è´¥: ${scriptName} (exit code: ${code})`);
                    this.logger.error('script', 'Script execution failed', {
                        script: scriptName,
                        exitCode: code,
                        errorOutput
                    }, error);
                    reject(error);
                }
            });

            child.on('error', (error) => {
                this.logger.error('script', 'Script spawn error', { script: scriptName }, error);
                reject(error);
            });
        });
    }

    ensureDirectory(dirPath) {
        try {
            fs.mkdirSync(dirPath, { recursive: true });
            return true;
        } catch (error) {
            this.logger.error('setup', 'Directory creation failed', { path: dirPath }, error);
            return false;
        }
    }

    checkNodeModules() {
        return fs.existsSync('node_modules');
    }

    async checkPermissions() {
        try {
            const testFile = path.join(this.config.targetDir, '.permission-test');
            fs.writeFileSync(testFile, 'test');
            fs.unlinkSync(testFile);
            return true;
        } catch (error) {
            return false;
        }
    }

    countFilesInDirectory(dirPath) {
        if (!fs.existsSync(dirPath)) return 0;
        
        let count = 0;
        const items = fs.readdirSync(dirPath);
        
        for (const item of items) {
            const itemPath = path.join(dirPath, item);
            const stats = fs.statSync(itemPath);
            
            if (stats.isFile()) {
                count++;
            } else if (stats.isDirectory()) {
                count += this.countFilesInDirectory(itemPath);
            }
        }
        
        return count;
    }

    async promptContinue() {
        if (this.config.skipConfirmations) return true;
        return await this.promptYesNo('\nç»§ç»­ä¸‹ä¸€æ­¥ï¼Ÿ');
    }

    async promptYesNo(question) {
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        return new Promise((resolve) => {
            rl.question(`${question} (y/N): `, (answer) => {
                rl.close();
                resolve(['y', 'yes', 'Y', 'YES'].includes(answer.trim()));
            });
        });
    }

    async waitForUserConfirmation(message) {
        const readline = require('readline');
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });

        return new Promise((resolve) => {
            rl.question(`${message} (æŒ‰ Enter ç»§ç»­): `, () => {
                rl.close();
                resolve();
            });
        });
    }

    async completeWorkflow() {
        console.log('\nğŸ‰ å·¥ä½œæµæ‰§è¡Œå®Œæˆï¼');
        
        const duration = Math.round((this.workflow.endTime - this.workflow.startTime) / 1000);
        const successRate = ((Object.keys(this.workflow.results).length) / this.steps.length) * 100;

        console.log(`â±ï¸  æ€»è€—æ—¶: ${duration} ç§’`);
        console.log(`ğŸ“ˆ å®Œæˆç‡: ${successRate.toFixed(1)}%`);
        
        if (this.workflow.errors.length > 0) {
            console.log(`âš ï¸  é‡åˆ° ${this.workflow.errors.length} ä¸ªé”™è¯¯`);
        }

        this.logger.info('workflow', 'Workflow completed', {
            duration,
            successRate,
            errorCount: this.workflow.errors.length
        });
    }

    async handleWorkflowError(error) {
        console.log('\nâŒ å·¥ä½œæµæ‰§è¡Œå¤±è´¥');
        console.log(`é”™è¯¯: ${error.message}`);
        
        this.workflow.endTime = new Date();
        await this.generateFinalReport();
        
        this.logger.error('workflow', 'Workflow failed', {
            currentStep: this.workflow.currentStep,
            completedSteps: Object.keys(this.workflow.results).length
        }, error);
    }
}

// CLIæ¥å£
async function main() {
    const args = process.argv.slice(2);
    
    const config = {
        mode: args.includes('--auto') ? 'auto' : 
              args.includes('--batch') ? 'batch' : 'interactive',
        dryRun: args.includes('--dry-run'),
        skipConfirmations: args.includes('--yes'),
        autoExecute: args.includes('--auto-execute'),
        logLevel: args.includes('--debug') ? 'DEBUG' : 'INFO'
    };

    try {
        console.log('ğŸš€ å¯åŠ¨æ–‡ä»¶æ¢å¤é›†æˆå·¥ä½œæµç³»ç»Ÿ');
        
        const workflow = new IntegratedWorkflowSystem(config);
        await workflow.execute();
        
        console.log('\nâœ… å·¥ä½œæµç³»ç»Ÿæ‰§è¡Œå®Œæˆ');
        process.exit(0);
        
    } catch (error) {
        console.error('\nâŒ å·¥ä½œæµç³»ç»Ÿæ‰§è¡Œå¤±è´¥:', error.message);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}

module.exports = IntegratedWorkflowSystem;


ä»»åŠ¡8ï¼šæ—¥å¿—å’ŒæŠ¥å‘Šç³»ç»Ÿå·²å®Œæˆå¹¶è§£å†³äº†æ‰€æœ‰æŠ€æœ¯é—®é¢˜ã€‚æ‚¨æˆåŠŸåˆ›å»ºäº†ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„æ—¥å¿—ç³»ç»Ÿï¼ŒåŒ…æ‹¬æ¼”ç¤ºç‰ˆæœ¬å’Œç”Ÿäº§ç‰ˆæœ¬ï¼Œå¹¶è§£å†³äº†å®šæ—¶å™¨æ¸…ç†å’Œè¿›ç¨‹é€€å‡ºçš„é—®é¢˜ã€‚

æ ¹æ®æˆ‘ä»¬çš„ä¸“ä¸šä¼˜å…ˆçº§åˆ†æï¼Œç°åœ¨åº”è¯¥ç»§ç»­æ‰§è¡Œä»»åŠ¡9ï¼šé›†æˆè„šæœ¬ç³»ç»Ÿã€‚è¿™æ˜¯å·¥ä½œæµè‡ªåŠ¨åŒ–çš„å…³é”®ç»„ä»¶ï¼Œå°†æŠŠæ‰€æœ‰å·²å®Œæˆçš„ç³»ç»Ÿæ•´åˆæˆä¸€ä¸ªç»Ÿä¸€çš„å·¥å…·ã€‚**ä»»åŠ¡9ï¼šé›†æˆå·¥ä½œæµç³»ç»Ÿå·²å®Œæˆï¼**

è¿™æ˜¯ä¸€ä¸ªä¼ä¸šçº§çš„å·¥ä½œæµorchestratorï¼Œå°†æ‰€æœ‰å·²å®Œæˆçš„ç³»ç»Ÿç»Ÿä¸€ç®¡ç†ï¼š

### æ ¸å¿ƒæ¶æ„
- **åæ­¥éª¤å·¥ä½œæµ**: ä»ç¯å¢ƒè®¾ç½®åˆ°æœ€ç»ˆæŠ¥å‘Šçš„å®Œæ•´æµç¨‹
- **ä¸‰ç§æ‰§è¡Œæ¨¡å¼**: interactiveï¼ˆäº¤äº’å¼ï¼‰ã€autoï¼ˆè‡ªåŠ¨ï¼‰ã€batchï¼ˆæ‰¹å¤„ç†ï¼‰
- **å…¨ç¨‹æ—¥å¿—è®°å½•**: é›†æˆæ—¥å¿—ç³»ç»Ÿï¼Œè®°å½•æ¯ä¸ªæ“ä½œçš„è¯¦ç»†ä¿¡æ¯
- **é”™è¯¯æ¢å¤**: æ”¯æŒæ­¥éª¤çº§é”™è¯¯å¤„ç†å’Œå·¥ä½œæµç»§ç»­

### æ™ºèƒ½ç‰¹æ€§
- **ä¾èµ–æ£€æŸ¥**: è‡ªåŠ¨éªŒè¯ç¯å¢ƒã€æƒé™ã€æ–‡ä»¶å®Œæ•´æ€§
- **è¿›åº¦è·Ÿè¸ª**: å®æ—¶æ˜¾ç¤ºå·¥ä½œæµè¿›åº¦å’Œæ­¥éª¤çŠ¶æ€
- **ç»“æœéªŒè¯**: æ¯ä¸ªæ­¥éª¤å®Œæˆåè‡ªåŠ¨éªŒè¯è¾“å‡º
- **åº¦é‡æ”¶é›†**: æ”¶é›†æ€§èƒ½æ•°æ®å’ŒæˆåŠŸç‡ç»Ÿè®¡

### ä½¿ç”¨æ–¹å¼
```bash
# äº¤äº’å¼æ¨¡å¼ï¼ˆæ¨èï¼‰
node integrated-workflow-system.js

# è‡ªåŠ¨æ¨¡å¼
node integrated-workflow-system.js --auto

# å¹²è¿è¡Œæ¨¡å¼
node integrated-workflow-system.js --dry-run

# è·³è¿‡ç¡®è®¤
node integrated-workflow-system.js --yes --auto-execute
```

ç°åœ¨æˆ‘ä»¬å·²ç»å®Œæˆäº†9ä¸ªæ ¸å¿ƒä»»åŠ¡ã€‚æ ¹æ®ä¸“ä¸šä¼˜å…ˆçº§åˆ†æï¼Œåªå‰©ä¸‹æœ€åä¸€ä¸ªä»»åŠ¡10ï¼šå®‰å…¨éªŒè¯ç³»ç»Ÿã€‚

è¿™ä¸ªé›†æˆç³»ç»Ÿå°†ç¡®ä¿æ•´ä¸ªæ¢å¤æµç¨‹çš„ä¸€è‡´æ€§å’Œå¯é æ€§ã€‚æ‚¨æƒ³ç»§ç»­å®Œæˆæœ€åçš„ä»»åŠ¡10ï¼Œè¿˜æ˜¯å…ˆæµ‹è¯•è¿™ä¸ªé›†æˆå·¥ä½œæµç³»ç»Ÿï¼Ÿ