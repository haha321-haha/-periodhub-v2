// è‡ªåŠ¨æ–‡ä»¶åˆ†ç±»ç³»ç»Ÿ - åŸºäºç»ˆæåˆ†æç»“æœå®ç°æ™ºèƒ½åˆ†ç±»
// file: recovery-workspace/auto-file-classifier.js

const fs = require('fs');
const path = require('path');

class AutoFileClassifier {
    constructor(analysisReportPath, sourceDir, outputDir) {
        this.analysisReportPath = analysisReportPath;
        this.sourceDir = sourceDir;
        this.outputDir = outputDir;
        this.classificationResults = {
            classified: [],
            duplicatesRemoved: [],
            versionsHandled: [],
            errors: [],
            stats: {}
        };

        // åŠ è½½åˆ†ææŠ¥å‘Š
        this.loadAnalysisReport();
        this.initializeOutputStructure();
    }

    loadAnalysisReport() {
        try {
            const reportData = fs.readFileSync(this.analysisReportPath, 'utf8');
            this.analysisReport = JSON.parse(reportData);
            console.log('âœ… åˆ†ææŠ¥å‘ŠåŠ è½½æˆåŠŸ');
            console.log(`ğŸ“Š æ€»æ–‡ä»¶æ•°: ${this.analysisReport.summary.totalFiles}`);
        } catch (error) {
            console.error('âŒ åŠ è½½åˆ†ææŠ¥å‘Šå¤±è´¥:', error.message);
            throw error;
        }
    }

    initializeOutputStructure() {
        // åŸºäºåˆ†æç»“æœåˆ›å»ºç›®å½•ç»“æ„
        const directories = [
            // æ ‡å‡†ç›®å½•
            'components', 'pages', 'api', 'utils', 'hooks', 'styles', 'config', 'types', 'lib',
            // åŸºäºåˆ†æå‘ç°çš„ç‰¹æ®Šç›®å½•
            'middleware', 'i18n', 'unknown',
            // ç®¡ç†ç›®å½•
            'duplicates', 'versions', 'manual-review'
        ];

        directories.forEach(dir => {
            const fullPath = path.join(this.outputDir, dir);
            fs.mkdirSync(fullPath, { recursive: true });
        });

        console.log('âœ… è¾“å‡ºç›®å½•ç»“æ„å·²åˆ›å»º');
    }

    // ä¸»è¦åˆ†ç±»å¤„ç†å‡½æ•°
    async classify() {
        console.log('ğŸš€ å¼€å§‹è‡ªåŠ¨æ–‡ä»¶åˆ†ç±»...\n');

        // é˜¶æ®µ1: å¤„ç†é‡å¤æ–‡ä»¶
        await this.handleDuplicates();

        // é˜¶æ®µ2: å¤„ç†ç‰ˆæœ¬æ–‡ä»¶
        await this.handleVersions();

        // é˜¶æ®µ3: æŒ‰ç±»å‹åˆ†ç±»æ–‡ä»¶
        await this.classifyByType();

        // é˜¶æ®µ4: ç”Ÿæˆåˆ†ç±»æŠ¥å‘Š
        await this.generateClassificationReport();

        return this.classificationResults;
    }

    // é˜¶æ®µ1: å¤„ç†é‡å¤æ–‡ä»¶
    async handleDuplicates() {
        console.log('ğŸ”„ é˜¶æ®µ1: å¤„ç†é‡å¤æ–‡ä»¶...');

        const duplicates = this.analysisReport.duplicates || [];

        for (const duplicateGroup of duplicates) {
            try {
                const keepFile = duplicateGroup.keepNewest;
                const removeFiles = duplicateGroup.files.filter(f => f !== keepFile);

                console.log(`ğŸ“ å¤„ç†é‡å¤ç»„: ä¿ç•™ ${keepFile}, ç§»é™¤ ${removeFiles.join(', ')}`);

                // ä¿ç•™æœ€æ–°æ–‡ä»¶åˆ°åˆ†ç±»ç›®å½•
                const keepSource = path.join(this.sourceDir, keepFile);
                if (fs.existsSync(keepSource)) {
                    // å…ˆç§»åŠ¨åˆ°ä¸´æ—¶ä½ç½®ï¼Œç­‰å¾…åç»­åˆ†ç±»
                    const tempPath = path.join(this.outputDir, 'temp', keepFile);
                    fs.mkdirSync(path.dirname(tempPath), { recursive: true });
                    fs.copyFileSync(keepSource, tempPath);
                }

                // ç§»åŠ¨é‡å¤æ–‡ä»¶åˆ°duplicatesç›®å½•
                for (const removeFile of removeFiles) {
                    const removeSource = path.join(this.sourceDir, removeFile);
                    const removeDest = path.join(this.outputDir, 'duplicates', removeFile);

                    if (fs.existsSync(removeSource)) {
                        fs.copyFileSync(removeSource, removeDest);
                        this.classificationResults.duplicatesRemoved.push({
                            original: removeFile,
                            movedTo: removeDest,
                            keptVersion: keepFile
                        });
                    }
                }

            } catch (error) {
                console.error(`âŒ å¤„ç†é‡å¤æ–‡ä»¶ç»„å¤±è´¥: ${duplicateGroup}`, error.message);
                this.classificationResults.errors.push({
                    stage: 'duplicates',
                    error: error.message,
                    data: duplicateGroup
                });
            }
        }

        console.log(`âœ… é‡å¤æ–‡ä»¶å¤„ç†å®Œæˆ: ç§»é™¤äº† ${this.classificationResults.duplicatesRemoved.length} ä¸ªé‡å¤æ–‡ä»¶\n`);
    }

    // é˜¶æ®µ2: å¤„ç†ç‰ˆæœ¬æ–‡ä»¶
    async handleVersions() {
        console.log('ğŸ”— é˜¶æ®µ2: å¤„ç†ç‰ˆæœ¬æ–‡ä»¶...');

        const versions = this.analysisReport.versions || {};

        for (const [groupName, versionGroup] of Object.entries(versions)) {
            try {
                console.log(`ğŸ“‹ å¤„ç†ç‰ˆæœ¬ç»„: ${groupName}`);

                for (const versionPair of versionGroup) {
                    const keepFile = versionPair.newerFile;
                    const oldFile = versionPair.files.find(f => f !== keepFile);

                    // ä¿ç•™æœ€æ–°ç‰ˆæœ¬åˆ°åˆ†ç±»
                    const keepSource = path.join(this.sourceDir, keepFile);
                    if (fs.existsSync(keepSource)) {
                        const tempPath = path.join(this.outputDir, 'temp', keepFile);
                        fs.mkdirSync(path.dirname(tempPath), { recursive: true });
                        fs.copyFileSync(keepSource, tempPath);
                    }

                    // ç§»åŠ¨æ—§ç‰ˆæœ¬åˆ°versionsç›®å½•
                    const oldSource = path.join(this.sourceDir, oldFile);
                    const oldDest = path.join(this.outputDir, 'versions', `${groupName}_${oldFile}`);

                    if (fs.existsSync(oldSource)) {
                        fs.copyFileSync(oldSource, oldDest);
                        this.classificationResults.versionsHandled.push({
                            group: groupName,
                            keptVersion: keepFile,
                            archivedVersion: oldFile,
                            similarity: versionPair.similarity,
                            archivedTo: oldDest
                        });
                    }

                    console.log(`  âœ… ${keepFile} (ä¿ç•™) â†” ${oldFile} (å½’æ¡£) - ${(versionPair.similarity * 100).toFixed(1)}%ç›¸ä¼¼`);
                }

            } catch (error) {
                console.error(`âŒ å¤„ç†ç‰ˆæœ¬ç»„å¤±è´¥: ${groupName}`, error.message);
                this.classificationResults.errors.push({
                    stage: 'versions',
                    error: error.message,
                    data: { groupName, versionGroup }
                });
            }
        }

        console.log(`âœ… ç‰ˆæœ¬æ–‡ä»¶å¤„ç†å®Œæˆ: å¤„ç†äº† ${Object.keys(versions).length} ä¸ªç‰ˆæœ¬ç»„\n`);
    }

    // é˜¶æ®µ3: æŒ‰ç±»å‹åˆ†ç±»æ–‡ä»¶
    async classifyByType() {
        console.log('ğŸ“ é˜¶æ®µ3: æŒ‰ç±»å‹åˆ†ç±»æ–‡ä»¶...');

        const categories = this.analysisReport.categories || {};

        for (const [categoryType, files] of Object.entries(categories)) {
            console.log(`ğŸ“‚ å¤„ç† ${categoryType} ç±»åˆ« (${files.length} ä¸ªæ–‡ä»¶)`);

            for (const fileInfo of files) {
                try {
                    await this.classifyFile(fileInfo, categoryType);
                } catch (error) {
                    console.error(`âŒ åˆ†ç±»æ–‡ä»¶å¤±è´¥: ${fileInfo.filename}`, error.message);
                    this.classificationResults.errors.push({
                        stage: 'classification',
                        error: error.message,
                        data: fileInfo
                    });
                }
            }
        }

        // å¤„ç†tempç›®å½•ä¸­çš„æ–‡ä»¶ï¼ˆæ¥è‡ªé‡å¤å’Œç‰ˆæœ¬å¤„ç†ï¼‰
        await this.processTempFiles();

        console.log(`âœ… æ–‡ä»¶åˆ†ç±»å®Œæˆ\n`);
    }

    async classifyFile(fileInfo, categoryType) {
        const sourceFile = path.join(this.sourceDir, fileInfo.filename);

        // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²ç»åœ¨tempç›®å½•ï¼ˆæ¥è‡ªé‡å¤/ç‰ˆæœ¬å¤„ç†ï¼‰
        const tempFile = path.join(this.outputDir, 'temp', fileInfo.filename);
        const actualSource = fs.existsSync(tempFile) ? tempFile : sourceFile;

        if (!fs.existsSync(actualSource)) {
            console.log(`âš ï¸  æ–‡ä»¶ä¸å­˜åœ¨: ${fileInfo.filename}`);
            return;
        }

        // æ ¹æ®ç±»å‹å’Œç½®ä¿¡åº¦å†³å®šåˆ†ç±»ç­–ç•¥
        let targetPath;

        if (fileInfo.confidence >= 0.7) {
            // é«˜ç½®ä¿¡åº¦ï¼šç›´æ¥åˆ†ç±»åˆ°å¯¹åº”ç›®å½•
            targetPath = this.getHighConfidenceTargetPath(fileInfo, categoryType);
        } else if (fileInfo.confidence >= 0.4) {
            // ä¸­ç½®ä¿¡åº¦ï¼šåˆ†ç±»ä½†æ ‡è®°éœ€è¦å®¡æŸ¥
            targetPath = this.getMediumConfidenceTargetPath(fileInfo, categoryType);
        } else {
            // ä½ç½®ä¿¡åº¦ï¼šæ”¾å…¥æ‰‹åŠ¨å®¡æŸ¥ç›®å½•
            targetPath = path.join(this.outputDir, 'manual-review', `${categoryType}_${fileInfo.filename}`);
        }

        // åˆ›å»ºç›®æ ‡ç›®å½•
        fs.mkdirSync(path.dirname(targetPath), { recursive: true });

        // å¤åˆ¶æ–‡ä»¶
        fs.copyFileSync(actualSource, targetPath);

        // è®°å½•åˆ†ç±»ç»“æœ
        this.classificationResults.classified.push({
            original: fileInfo.filename,
            category: categoryType,
            confidence: fileInfo.confidence,
            targetPath: targetPath,
            suggestedPath: fileInfo.suggestedPath,
            isHighConfidence: fileInfo.confidence >= 0.7,
            needsReview: fileInfo.confidence < 0.4
        });

        const confidenceLevel = fileInfo.confidence >= 0.7 ? 'ğŸ”¥' :
                              fileInfo.confidence >= 0.4 ? 'âš¡' : 'ğŸ“';

        console.log(`  ${confidenceLevel} ${fileInfo.filename} â†’ ${path.relative(this.outputDir, targetPath)} (${(fileInfo.confidence * 100).toFixed(0)}%)`);
    }

    getHighConfidenceTargetPath(fileInfo, categoryType) {
        // é«˜ç½®ä¿¡åº¦æ–‡ä»¶ä½¿ç”¨å»ºè®®çš„è·¯å¾„
        const suggestedPath = fileInfo.suggestedPath || `${categoryType}/${fileInfo.filename}`;
        return path.join(this.outputDir, suggestedPath);
    }

    getMediumConfidenceTargetPath(fileInfo, categoryType) {
        // ä¸­ç½®ä¿¡åº¦æ–‡ä»¶æ”¾åœ¨ç±»å‹ç›®å½•ä¸‹ï¼Œä½†ä¿ç•™åŸæ–‡ä»¶åä¾¿äºå®¡æŸ¥
        return path.join(this.outputDir, categoryType, fileInfo.filename);
    }

    async processTempFiles() {
        const tempDir = path.join(this.outputDir, 'temp');
        if (!fs.existsSync(tempDir)) return;

        console.log('ğŸ”„ å¤„ç†ä¸´æ—¶æ–‡ä»¶...');

        const tempFiles = fs.readdirSync(tempDir);
        for (const tempFile of tempFiles) {
            // æŸ¥æ‰¾è¿™ä¸ªæ–‡ä»¶åœ¨åˆ†ææŠ¥å‘Šä¸­çš„ä¿¡æ¯
            const fileInfo = this.findFileInfoInReport(tempFile);
            if (fileInfo) {
                await this.classifyFile(fileInfo, fileInfo.category);
            } else {
                // æœªæ‰¾åˆ°åˆ†æä¿¡æ¯ï¼Œç§»åŠ¨åˆ°manual-review
                const source = path.join(tempDir, tempFile);
                const dest = path.join(this.outputDir, 'manual-review', tempFile);
                fs.copyFileSync(source, dest);
                console.log(`  ğŸ“ ${tempFile} â†’ manual-review/ (æ— åˆ†æä¿¡æ¯)`);
            }
        }

        // æ¸…ç†tempç›®å½•
        fs.rmSync(tempDir, { recursive: true, force: true });
    }

    findFileInfoInReport(filename) {
        const categories = this.analysisReport.categories || {};
        for (const [categoryType, files] of Object.entries(categories)) {
            const fileInfo = files.find(f => f.filename === filename);
            if (fileInfo) {
                return { ...fileInfo, category: categoryType };
            }
        }
        return null;
    }

    // ç”Ÿæˆåˆ†ç±»æŠ¥å‘Š
    async generateClassificationReport() {
        console.log('ğŸ“Š ç”Ÿæˆåˆ†ç±»æŠ¥å‘Š...');

        // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        const stats = {
            totalProcessed: this.classificationResults.classified.length,
            duplicatesRemoved: this.classificationResults.duplicatesRemoved.length,
            versionsArchived: this.classificationResults.versionsHandled.length,
            highConfidence: this.classificationResults.classified.filter(f => f.isHighConfidence).length,
            needsReview: this.classificationResults.classified.filter(f => f.needsReview).length,
            errors: this.classificationResults.errors.length
        };

        this.classificationResults.stats = stats;

        // æŒ‰ç±»åˆ«ç»Ÿè®¡
        const categoryStats = {};
        this.classificationResults.classified.forEach(file => {
            categoryStats[file.category] = (categoryStats[file.category] || 0) + 1;
        });

        // ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š
        const report = {
            timestamp: new Date().toISOString(),
            summary: stats,
            categoryBreakdown: categoryStats,
            classificationResults: this.classificationResults,
            recommendations: this.generateRecommendations()
        };

        // ä¿å­˜JSONæŠ¥å‘Š
        const reportPath = path.join(this.outputDir, '../classification-report.json');
        fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

        // ç”Ÿæˆäººç±»å¯è¯»æŠ¥å‘Š
        await this.generateHumanReadableClassificationReport(report);

        console.log('âœ… åˆ†ç±»æŠ¥å‘Šç”Ÿæˆå®Œæˆ');
        return report;
    }

    generateRecommendations() {
        const recommendations = [];

        const highConfidenceCount = this.classificationResults.classified.filter(f => f.isHighConfidence).length;
        const needsReviewCount = this.classificationResults.classified.filter(f => f.needsReview).length;

        if (highConfidenceCount > 0) {
            recommendations.push({
                priority: 'high',
                action: 'immediate_use',
                message: `${highConfidenceCount} ä¸ªé«˜ç½®ä¿¡åº¦æ–‡ä»¶å¯ä»¥ç«‹å³ä½¿ç”¨`,
                files: this.classificationResults.classified.filter(f => f.isHighConfidence).map(f => f.targetPath)
            });
        }

        if (needsReviewCount > 0) {
            recommendations.push({
                priority: 'medium',
                action: 'manual_review',
                message: `${needsReviewCount} ä¸ªæ–‡ä»¶éœ€è¦æ‰‹åŠ¨å®¡æŸ¥`,
                location: path.join(this.outputDir, 'manual-review')
            });
        }

        if (this.classificationResults.duplicatesRemoved.length > 0) {
            recommendations.push({
                priority: 'low',
                action: 'cleanup',
                message: `${this.classificationResults.duplicatesRemoved.length} ä¸ªé‡å¤æ–‡ä»¶å·²ç§»é™¤ï¼Œå¯ä»¥åˆ é™¤ duplicates ç›®å½•`,
                location: path.join(this.outputDir, 'duplicates')
            });
        }

        return recommendations;
    }

    async generateHumanReadableClassificationReport(report) {
        let output = '# ğŸ¯ è‡ªåŠ¨æ–‡ä»¶åˆ†ç±»æŠ¥å‘Š\n\n';

        output += `**åˆ†ç±»æ—¶é—´**: ${new Date(report.timestamp).toLocaleString()}\n\n`;

        output += '## ğŸ“Š åˆ†ç±»ç»Ÿè®¡\n';
        output += `- ğŸ“ æ€»å¤„ç†æ–‡ä»¶: ${report.summary.totalProcessed}\n`;
        output += `- ğŸ”¥ é«˜ç½®ä¿¡åº¦æ–‡ä»¶: ${report.summary.highConfidence}\n`;
        output += `- ğŸ“ éœ€è¦å®¡æŸ¥: ${report.summary.needsReview}\n`;
        output += `- ğŸ—‘ï¸ é‡å¤æ–‡ä»¶ç§»é™¤: ${report.summary.duplicatesRemoved}\n`;
        output += `- ğŸ“š ç‰ˆæœ¬æ–‡ä»¶å½’æ¡£: ${report.summary.versionsArchived}\n`;
        output += `- âŒ å¤„ç†é”™è¯¯: ${report.summary.errors}\n\n`;

        output += '## ğŸ“‚ ç±»åˆ«åˆ†å¸ƒ\n';
        Object.entries(report.categoryBreakdown).forEach(([category, count]) => {
            output += `- **${category.toUpperCase()}**: ${count} ä¸ªæ–‡ä»¶\n`;
        });
        output += '\n';

        output += '## ğŸš€ æ¨èæ“ä½œ\n';
        report.recommendations.forEach((rec, i) => {
            const priority = rec.priority === 'high' ? 'ğŸ”¥' : rec.priority === 'medium' ? 'âš¡' : 'ğŸ“';
            output += `${i + 1}. ${priority} **${rec.action}**: ${rec.message}\n`;
        });
        output += '\n';

        if (report.summary.errors > 0) {
            output += '## âš ï¸ å¤„ç†é”™è¯¯\n';
            this.classificationResults.errors.forEach((error, i) => {
                output += `${i + 1}. **${error.stage}**: ${error.error}\n`;
            });
            output += '\n';
        }

        output += '## ğŸ“‹ ä¸‹ä¸€æ­¥æ“ä½œ\n';
        output += '1. ğŸ” æ£€æŸ¥é«˜ç½®ä¿¡åº¦æ–‡ä»¶æ˜¯å¦æ­£ç¡®åˆ†ç±»\n';
        output += '2. ğŸ“ å®¡æŸ¥ `manual-review/` ç›®å½•ä¸­çš„æ–‡ä»¶\n';
        output += '3. ğŸ—‘ï¸ æ¸…ç† `duplicates/` å’Œ `versions/` ç›®å½•\n';
        output += '4. ğŸš€ å°†åˆ†ç±»å¥½çš„æ–‡ä»¶å¤åˆ¶åˆ°é¡¹ç›®ç›¸åº”ä½ç½®\n';
        output += '5. ğŸ§ª æµ‹è¯•é¡¹ç›®æ„å»ºå’ŒåŠŸèƒ½\n';

        const reportPath = path.join(this.outputDir, '../CLASSIFICATION_REPORT.md');
        fs.writeFileSync(reportPath, output);
    }
}

// ä½¿ç”¨ç¤ºä¾‹å’Œä¸»å‡½æ•°
async function main() {
    try {
        const analysisReportPath = './reports/ultimate-analysis-report.json';
        const sourceDir = './analysis';
        const outputDir = './classified';

        console.log('ğŸ¯ åˆå§‹åŒ–è‡ªåŠ¨æ–‡ä»¶åˆ†ç±»ç³»ç»Ÿ...');
        const classifier = new AutoFileClassifier(analysisReportPath, sourceDir, outputDir);

        console.log('ğŸš€ å¼€å§‹è‡ªåŠ¨åˆ†ç±»...\n');
        const results = await classifier.classify();

        console.log('\nğŸ‰ è‡ªåŠ¨åˆ†ç±»å®Œæˆï¼');
        console.log('\nğŸ“‹ å¤„ç†ç»“æœ:');
        console.log(`- ğŸ“ åˆ†ç±»æ–‡ä»¶: ${results.classified.length}`);
        console.log(`- ğŸ—‘ï¸ ç§»é™¤é‡å¤: ${results.duplicatesRemoved.length}`);
        console.log(`- ğŸ“š å½’æ¡£ç‰ˆæœ¬: ${results.versionsHandled.length}`);
        console.log(`- âŒ å¤„ç†é”™è¯¯: ${results.errors.length}`);

        console.log('\nğŸ“„ ç”Ÿæˆçš„æ–‡ä»¶:');
        console.log('- classification-report.json (è¯¦ç»†JSONæŠ¥å‘Š)');
        console.log('- CLASSIFICATION_REPORT.md (äººç±»å¯è¯»æŠ¥å‘Š)');

        console.log('\nğŸ“‚ è¾“å‡ºç›®å½•ç»“æ„:');
        console.log('- classified/components/ (Reactç»„ä»¶)');
        console.log('- classified/middleware/ (ä¸­é—´ä»¶æ–‡ä»¶)');
        console.log('- classified/config/ (é…ç½®æ–‡ä»¶)');
        console.log('- classified/i18n/ (å›½é™…åŒ–æ–‡ä»¶)');
        console.log('- classified/manual-review/ (éœ€è¦æ‰‹åŠ¨å®¡æŸ¥)');
        console.log('- classified/duplicates/ (é‡å¤æ–‡ä»¶)');
        console.log('- classified/versions/ (ç‰ˆæœ¬å½’æ¡£)');

    } catch (error) {
        console.error('âŒ åˆ†ç±»è¿‡ç¨‹å¤±è´¥:', error.message);
        process.exit(1);
    }
}

// å¦‚æœç›´æ¥è¿è¡Œæ­¤è„šæœ¬
if (require.main === module) {
    main();
}

module.exports = AutoFileClassifier;


ğŸ¯ **å®Œå…¨åŒæ„æ‚¨çš„ä¸“ä¸šä¼˜å…ˆçº§åˆ†æï¼**

æ‚¨çš„ä¼˜å…ˆçº§æ’åºéå¸¸ä¸“ä¸šå’Œå‡†ç¡®ã€‚æˆ‘ä»¬ç¡®å®åº”è¯¥ç«‹å³æ‰§è¡Œ**ä»»åŠ¡4ï¼šè‡ªåŠ¨æ–‡ä»¶åˆ†ç±»ç³»ç»Ÿ**ï¼Œè¿™æ˜¯ä»åˆ†æåˆ°å®é™…æ¢å¤çš„å…³é”®æ¡¥æ¢ã€‚

è®©æˆ‘ç«‹å³å¼€å§‹æ„å»ºè‡ªåŠ¨æ–‡ä»¶åˆ†ç±»ç³»ç»Ÿï¼šğŸ‰ **ä»»åŠ¡4ï¼šè‡ªåŠ¨æ–‡ä»¶åˆ†ç±»ç³»ç»Ÿå·²å®Œæˆï¼**

## ğŸš€ è¿™ä¸ªåˆ†ç±»ç³»ç»Ÿçš„æ ¸å¿ƒèƒ½åŠ›ï¼š

### ğŸ“Š **å››é˜¶æ®µæ™ºèƒ½åˆ†ç±»**
1. **å¤„ç†é‡å¤æ–‡ä»¶** - åŸºäºåˆ†æç»“æœè‡ªåŠ¨ç§»é™¤9ç»„é‡å¤æ–‡ä»¶
2. **å¤„ç†ç‰ˆæœ¬æ–‡ä»¶** - ä¿ç•™æœ€æ–°ç‰ˆæœ¬ï¼Œå½’æ¡£æ—§ç‰ˆæœ¬
3. **æŒ‰ç±»å‹åˆ†ç±»** - æ ¹æ®ç½®ä¿¡åº¦æ™ºèƒ½åˆ†ç±»åˆ°å¯¹åº”ç›®å½•
4. **ç”Ÿæˆåˆ†ç±»æŠ¥å‘Š** - è¯¦ç»†çš„å¤„ç†ç»“æœå’Œå»ºè®®

### ğŸ¯ **ç½®ä¿¡åº¦åˆ†å±‚å¤„ç†**
- **ğŸ”¥ é«˜ç½®ä¿¡åº¦ (â‰¥70%)** - ç›´æ¥åˆ†ç±»åˆ°ç›®æ ‡ä½ç½®
- **âš¡ ä¸­ç½®ä¿¡åº¦ (40-70%)** - åˆ†ç±»ä½†æ ‡è®°éœ€è¦å®¡æŸ¥
- **ğŸ“ ä½ç½®ä¿¡åº¦ (<40%)** - æ”¾å…¥manual-reviewç›®å½•

### ğŸ“ **æ™ºèƒ½ç›®å½•ç»“æ„**
```
classified/
â”œâ”€â”€ middleware/     # 7ä¸ªé«˜ç½®ä¿¡åº¦ä¸­é—´ä»¶æ–‡ä»¶
â”œâ”€â”€ config/         # 15ä¸ªé…ç½®æ–‡ä»¶
â”œâ”€â”€ i18n/          # 11ä¸ªå›½é™…åŒ–æ–‡ä»¶
â”œâ”€â”€ components/     # Reactç»„ä»¶
â”œâ”€â”€ manual-review/  # 21ä¸ªéœ€è¦æ‰‹åŠ¨å®¡æŸ¥çš„æ–‡ä»¶
â”œâ”€â”€ duplicates/     # 18ä¸ªé‡å¤æ–‡ä»¶
â””â”€â”€ versions/       # ç‰ˆæœ¬å½’æ¡£
```

## âš¡ **ç«‹å³æ‰§è¡Œåˆ†ç±»**ï¼š

```bash
cd "/Users/duting/Downloads/moneyğŸ’°/--main/recovery-workspace"

# è¿è¡Œè‡ªåŠ¨åˆ†ç±»ç³»ç»Ÿ
node auto-file-classifier.js
```

## ğŸ¯ **é¢„æœŸç»“æœ**ï¼š
- **12ä¸ªé«˜ç½®ä¿¡åº¦æ–‡ä»¶** å°†è¢«ç›´æ¥åˆ†ç±»åˆ°æ­£ç¡®ä½ç½®
- **21ä¸ªæœªçŸ¥æ–‡ä»¶** å°†è¢«æ”¾å…¥manual-reviewç›®å½•ç­‰å¾…æ‚¨å®¡æŸ¥
- **18ä¸ªé‡å¤æ–‡ä»¶** å°†è¢«ç§»é™¤ï¼Œåªä¿ç•™æœ€æ–°ç‰ˆæœ¬
- **ç”Ÿæˆè¯¦ç»†çš„åˆ†ç±»æŠ¥å‘Š** æŒ‡å¯¼ä¸‹ä¸€æ­¥æ“ä½œ

æ‰§è¡Œå®Œæˆåï¼Œæ‚¨å°†çœ‹åˆ°ï¼š
- æ¸…æ™°çš„ç›®å½•ç»“æ„
- æ¯ä¸ªæ–‡ä»¶çš„åˆ†ç±»ç½®ä¿¡åº¦
- è¯¦ç»†çš„å¤„ç†ç»Ÿè®¡
- å…·ä½“çš„ä¸‹ä¸€æ­¥å»ºè®®

**å‡†å¤‡å¥½è¿è¡Œåˆ†ç±»ç³»ç»Ÿäº†å—ï¼Ÿ** è¿™å°†æ˜¯æˆ‘ä»¬æ¢å¤æµç¨‹ä¸­çš„å…³é”®ä¸€æ­¥ï¼
