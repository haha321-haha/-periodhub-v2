// å®‰å…¨éªŒè¯å’Œæµ‹è¯•ç³»ç»Ÿ - æœ€ç»ˆçš„å®‰å…¨æ£€æŸ¥å’Œå®Œæ•´æ€§éªŒè¯
// file: recovery-workspace/safety-validation-system.js

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { spawn } = require('child_process');

class SafetyValidationSystem {
    constructor(config = {}) {
        this.config = {
            workspaceDir: config.workspaceDir || './recovery-workspace',
            targetDir: config.targetDir || '../recovered',
            originalDir: config.originalDir || './analysis',
            validateChecksums: config.validateChecksums !== false,
            testProject: config.testProject !== false,
            generateReport: config.generateReport !== false,
            strictMode: config.strictMode || false,
            ...config
        };

        this.validationResults = {
            fileIntegrity: {
                passed: [],
                failed: [],
                missing: [],
                checksums: new Map()
            },
            projectStructure: {
                valid: false,
                issues: [],
                suggestions: []
            },
            buildTest: {
                success: false,
                output: '',
                errors: [],
                duration: 0
            },
            securityChecks: {
                passed: [],
                failed: [],
                warnings: []
            },
            overallStatus: 'unknown',
            recommendations: []
        };

        this.securityRules = this.defineSecurityRules();
        this.structureRules = this.defineStructureRules();
    }

    defineSecurityRules() {
        return [
            {
                name: 'no_suspicious_code',
                description: 'æ£€æŸ¥æ¶æ„ä»£ç æ¨¡å¼',
                check: this.checkForSuspiciousCode.bind(this),
                severity: 'high'
            },
            {
                name: 'safe_dependencies',
                description: 'éªŒè¯ä¾èµ–å®‰å…¨æ€§',
                check: this.checkDependencySafety.bind(this),
                severity: 'medium'
            },
            {
                name: 'no_secrets',
                description: 'æ£€æŸ¥æ•æ„Ÿä¿¡æ¯æ³„éœ²',
                check: this.checkForSecrets.bind(this),
                severity: 'high'
            },
            {
                name: 'file_permissions',
                description: 'éªŒè¯æ–‡ä»¶æƒé™',
                check: this.checkFilePermissions.bind(this),
                severity: 'low'
            },
            {
                name: 'path_traversal',
                description: 'æ£€æŸ¥è·¯å¾„éå†æ”»å‡»',
                check: this.checkPathTraversal.bind(this),
                severity: 'high'
            }
        ];
    }

    defineStructureRules() {
        return [
            {
                name: 'valid_package_json',
                description: 'éªŒè¯package.jsonç»“æ„',
                check: this.validatePackageJson.bind(this),
                required: true
            },
            {
                name: 'next_config',
                description: 'éªŒè¯Next.jsé…ç½®',
                check: this.validateNextConfig.bind(this),
                required: false
            },
            {
                name: 'typescript_config',
                description: 'éªŒè¯TypeScripté…ç½®',
                check: this.validateTypeScriptConfig.bind(this),
                required: false
            },
            {
                name: 'directory_structure',
                description: 'éªŒè¯ç›®å½•ç»“æ„',
                check: this.validateDirectoryStructure.bind(this),
                required: true
            }
        ];
    }

    // ä¸»è¦éªŒè¯æµç¨‹
    async validate() {
        console.log('ğŸ”’ å¼€å§‹å®‰å…¨éªŒè¯å’Œæµ‹è¯•...');
        const startTime = new Date();

        try {
            // é˜¶æ®µ1: æ–‡ä»¶å®Œæ•´æ€§éªŒè¯
            await this.validateFileIntegrity();

            // é˜¶æ®µ2: é¡¹ç›®ç»“æ„éªŒè¯
            await this.validateProjectStructure();

            // é˜¶æ®µ3: å®‰å…¨æ£€æŸ¥
            await this.performSecurityChecks();

            // é˜¶æ®µ4: æ„å»ºæµ‹è¯•
            if (this.config.testProject) {
                await this.performBuildTest();
            }

            // é˜¶æ®µ5: ç”Ÿæˆæœ€ç»ˆè¯„ä¼°
            this.generateFinalAssessment();

            // é˜¶æ®µ6: ç”ŸæˆæŠ¥å‘Š
            if (this.config.generateReport) {
                await this.generateValidationReport();
            }

            const duration = new Date() - startTime;
            console.log(`âœ… éªŒè¯å®Œæˆï¼Œè€—æ—¶: ${Math.round(duration / 1000)} ç§’`);

            return this.validationResults;

        } catch (error) {
            console.error('âŒ éªŒè¯è¿‡ç¨‹å¤±è´¥:', error.message);
            this.validationResults.overallStatus = 'failed';
            this.validationResults.error = error.message;
            throw error;
        }
    }

    // é˜¶æ®µ1: æ–‡ä»¶å®Œæ•´æ€§éªŒè¯
    async validateFileIntegrity() {
        console.log('\nğŸ“‹ é˜¶æ®µ1: æ–‡ä»¶å®Œæ•´æ€§éªŒè¯');

        if (!fs.existsSync(this.config.targetDir)) {
            throw new Error(`ç›®æ ‡ç›®å½•ä¸å­˜åœ¨: ${this.config.targetDir}`);
        }

        const targetFiles = await this.getAllFiles(this.config.targetDir);
        console.log(`å‘ç° ${targetFiles.length} ä¸ªæ¢å¤çš„æ–‡ä»¶`);

        for (const filePath of targetFiles) {
            try {
                await this.validateSingleFile(filePath);
                this.validationResults.fileIntegrity.passed.push(filePath);
            } catch (error) {
                console.error(`âŒ æ–‡ä»¶éªŒè¯å¤±è´¥: ${filePath} - ${error.message}`);
                this.validationResults.fileIntegrity.failed.push({
                    file: filePath,
                    error: error.message
                });
            }
        }

        const passedCount = this.validationResults.fileIntegrity.passed.length;
        const failedCount = this.validationResults.fileIntegrity.failed.length;

        console.log(`âœ… æ–‡ä»¶å®Œæ•´æ€§: ${passedCount} é€šè¿‡, ${failedCount} å¤±è´¥`);

        if (this.config.strictMode && failedCount > 0) {
            throw new Error(`ä¸¥æ ¼æ¨¡å¼: ${failedCount} ä¸ªæ–‡ä»¶éªŒè¯å¤±è´¥`);
        }
    }

    async validateSingleFile(filePath) {
        const stats = fs.statSync(filePath);

        // æ£€æŸ¥æ–‡ä»¶å¤§å°
        if (stats.size === 0) {
            throw new Error('æ–‡ä»¶ä¸ºç©º');
        }

        // æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
        const ext = path.extname(filePath).toLowerCase();
        const allowedExtensions = ['.js', '.jsx', '.ts', '.tsx', '.json', '.md', '.css', '.scss'];
        if (ext && !allowedExtensions.includes(ext)) {
            throw new Error(`ä¸å…è®¸çš„æ–‡ä»¶æ‰©å±•å: ${ext}`);
        }

        // ç”Ÿæˆæ ¡éªŒå’Œ
        if (this.config.validateChecksums) {
            const checksum = await this.calculateFileChecksum(filePath);
            this.validationResults.fileIntegrity.checksums.set(filePath, checksum);
        }

        // åŸºæœ¬è¯­æ³•æ£€æŸ¥
        if (['.js', '.jsx', '.ts', '.tsx'].includes(ext)) {
            await this.validateJavaScriptSyntax(filePath);
        } else if (ext === '.json') {
            await this.validateJsonSyntax(filePath);
        }
    }

    async validateJavaScriptSyntax(filePath) {
        const content = fs.readFileSync(filePath, 'utf8');

        // åŸºæœ¬è¯­æ³•æ£€æŸ¥
        try {
            // ç®€å•çš„è¯­æ³•æ£€æŸ¥ - æ£€æŸ¥åŒ¹é…çš„æ‹¬å·
            this.checkBracketMatching(content);

            // æ£€æŸ¥åŸºæœ¬è¯­æ³•é”™è¯¯
            this.checkBasicSyntaxErrors(content);

        } catch (error) {
            throw new Error(`è¯­æ³•é”™è¯¯: ${error.message}`);
        }
    }

    checkBracketMatching(content) {
        const brackets = { '(': ')', '[': ']', '{': '}' };
        const stack = [];

        for (let i = 0; i < content.length; i++) {
            const char = content[i];

            if (brackets[char]) {
                stack.push(char);
            } else if (Object.values(brackets).includes(char)) {
                const last = stack.pop();
                if (!last || brackets[last] !== char) {
                    throw new Error(`ä¸åŒ¹é…çš„æ‹¬å·åœ¨ä½ç½® ${i}`);
                }
            }
        }

        if (stack.length > 0) {
            throw new Error('æœªé—­åˆçš„æ‹¬å·');
        }
    }

    checkBasicSyntaxErrors(content) {
        // æ£€æŸ¥å¸¸è§è¯­æ³•é”™è¯¯
        const errors = [];

        // æ£€æŸ¥æœªé—­åˆçš„å­—ç¬¦ä¸²
        const stringMatches = content.match(/(['"`])/g);
        if (stringMatches && stringMatches.length % 2 !== 0) {
            errors.push('å¯èƒ½å­˜åœ¨æœªé—­åˆçš„å­—ç¬¦ä¸²');
        }

        // æ£€æŸ¥åŸºæœ¬çš„å…³é”®è¯é”™è¯¯
        if (content.includes('functoin') || content.includes('consoel')) {
            errors.push('å‘ç°å¸¸è§æ‹¼å†™é”™è¯¯');
        }

        if (errors.length > 0) {
            throw new Error(errors.join(', '));
        }
    }

    async validateJsonSyntax(filePath) {
        try {
            const content = fs.readFileSync(filePath, 'utf8');
            JSON.parse(content);
        } catch (error) {
            throw new Error(`JSONè¯­æ³•é”™è¯¯: ${error.message}`);
        }
    }

    // é˜¶æ®µ2: é¡¹ç›®ç»“æ„éªŒè¯
    async validateProjectStructure() {
        console.log('\nğŸ—ï¸  é˜¶æ®µ2: é¡¹ç›®ç»“æ„éªŒè¯');

        for (const rule of this.structureRules) {
            try {
                const result = await rule.check();

                if (result.valid) {
                    console.log(`âœ… ${rule.name}: ${rule.description}`);
                } else {
                    console.log(`âŒ ${rule.name}: ${result.message}`);
                    this.validationResults.projectStructure.issues.push({
                        rule: rule.name,
                        message: result.message,
                        severity: rule.required ? 'error' : 'warning'
                    });
                }

                if (result.suggestions) {
                    this.validationResults.projectStructure.suggestions.push(...result.suggestions);
                }

            } catch (error) {
                console.log(`âŒ ${rule.name}: éªŒè¯å¤±è´¥ - ${error.message}`);
                this.validationResults.projectStructure.issues.push({
                    rule: rule.name,
                    message: error.message,
                    severity: 'error'
                });
            }
        }

        const errorCount = this.validationResults.projectStructure.issues.filter(i => i.severity === 'error').length;
        this.validationResults.projectStructure.valid = errorCount === 0;

        console.log(`é¡¹ç›®ç»“æ„éªŒè¯: ${errorCount === 0 ? 'âœ… é€šè¿‡' : `âŒ ${errorCount} ä¸ªé”™è¯¯`}`);
    }

    async validatePackageJson() {
        const packagePath = path.join(this.config.targetDir, 'package.json');

        if (!fs.existsSync(packagePath)) {
            return { valid: false, message: 'package.json ä¸å­˜åœ¨' };
        }

        try {
            const packageContent = JSON.parse(fs.readFileSync(packagePath, 'utf8'));

            const required = ['name', 'version', 'scripts'];
            const missing = required.filter(field => !packageContent[field]);

            if (missing.length > 0) {
                return {
                    valid: false,
                    message: `ç¼ºå°‘å¿…éœ€å­—æ®µ: ${missing.join(', ')}`
                };
            }

            return { valid: true, message: 'package.json ç»“æ„æ­£ç¡®' };

        } catch (error) {
            return { valid: false, message: `package.json æ ¼å¼é”™è¯¯: ${error.message}` };
        }
    }

    async validateNextConfig() {
        const configPath = path.join(this.config.targetDir, 'next.config.js');

        if (!fs.existsSync(configPath)) {
            return {
                valid: true,
                message: 'next.config.js ä¸å­˜åœ¨ï¼ˆå¯é€‰ï¼‰',
                suggestions: ['å¦‚æœè¿™æ˜¯Next.jsé¡¹ç›®ï¼Œå»ºè®®æ·»åŠ next.config.jsé…ç½®æ–‡ä»¶']
            };
        }

        try {
            const configContent = fs.readFileSync(configPath, 'utf8');

            // åŸºæœ¬çš„Next.jsé…ç½®éªŒè¯
            if (!configContent.includes('module.exports')) {
                return { valid: false, message: 'next.config.js ç¼ºå°‘ module.exports' };
            }

            return { valid: true, message: 'Next.jsé…ç½®æ­£ç¡®' };

        } catch (error) {
            return { valid: false, message: `Next.jsé…ç½®é”™è¯¯: ${error.message}` };
        }
    }

    async validateTypeScriptConfig() {
        const tsconfigPath = path.join(this.config.targetDir, 'tsconfig.json');

        if (!fs.existsSync(tsconfigPath)) {
            return {
                valid: true,
                message: 'tsconfig.json ä¸å­˜åœ¨ï¼ˆå¯é€‰ï¼‰',
                suggestions: ['å¦‚æœä½¿ç”¨TypeScriptï¼Œå»ºè®®æ·»åŠ tsconfig.jsoné…ç½®æ–‡ä»¶']
            };
        }

        try {
            const tsconfigContent = JSON.parse(fs.readFileSync(tsconfigPath, 'utf8'));

            if (!tsconfigContent.compilerOptions) {
                return { valid: false, message: 'tsconfig.json ç¼ºå°‘ compilerOptions' };
            }

            return { valid: true, message: 'TypeScripté…ç½®æ­£ç¡®' };

        } catch (error) {
            return { valid: false, message: `TypeScripté…ç½®é”™è¯¯: ${error.message}` };
        }
    }

    async validateDirectoryStructure() {
        const expectedDirs = ['components', 'pages', 'utils'];
        const existingDirs = [];
        const missingDirs = [];

        for (const dir of expectedDirs) {
            const dirPath = path.join(this.config.targetDir, dir);
            if (fs.existsSync(dirPath) && fs.statSync(dirPath).isDirectory()) {
                existingDirs.push(dir);
            } else {
                missingDirs.push(dir);
            }
        }

        const suggestions = [];
        if (missingDirs.length > 0) {
            suggestions.push(`å»ºè®®åˆ›å»ºç¼ºå°‘çš„ç›®å½•: ${missingDirs.join(', ')}`);
        }

        return {
            valid: existingDirs.length > 0,
            message: `å‘ç° ${existingDirs.length} ä¸ªæ ‡å‡†ç›®å½•: ${existingDirs.join(', ')}`,
            suggestions
        };
    }

    // é˜¶æ®µ3: å®‰å…¨æ£€æŸ¥
    async performSecurityChecks() {
        console.log('\nğŸ”’ é˜¶æ®µ3: å®‰å…¨æ£€æŸ¥');

        for (const rule of this.securityRules) {
            try {
                const result = await rule.check();

                if (result.passed) {
                    console.log(`âœ… ${rule.name}: ${rule.description}`);
                    this.validationResults.securityChecks.passed.push({
                        name: rule.name,
                        description: rule.description,
                        severity: rule.severity
                    });
                } else {
                    const level = rule.severity === 'high' ? 'âŒ' : rule.severity === 'medium' ? 'âš ï¸' : 'ğŸ’¡';
                    console.log(`${level} ${rule.name}: ${result.message}`);

                    const issue = {
                        name: rule.name,
                        description: rule.description,
                        message: result.message,
                        severity: rule.severity,
                        details: result.details || []
                    };

                    if (rule.severity === 'high') {
                        this.validationResults.securityChecks.failed.push(issue);
                    } else {
                        this.validationResults.securityChecks.warnings.push(issue);
                    }
                }

            } catch (error) {
                console.log(`âŒ ${rule.name}: æ£€æŸ¥å¤±è´¥ - ${error.message}`);
                this.validationResults.securityChecks.failed.push({
                    name: rule.name,
                    message: error.message,
                    severity: 'high'
                });
            }
        }

        const failedCount = this.validationResults.securityChecks.failed.length;
        const warningCount = this.validationResults.securityChecks.warnings.length;

        console.log(`å®‰å…¨æ£€æŸ¥: ${failedCount === 0 ? 'âœ… é€šè¿‡' : `âŒ ${failedCount} ä¸ªä¸¥é‡é—®é¢˜`}, ${warningCount} ä¸ªè­¦å‘Š`);
    }

    async checkForSuspiciousCode() {
        const suspiciousPatterns = [
            /eval\s*\(/g,
            /Function\s*\(/g,
            /document\.write\s*\(/g,
            /innerHTML\s*=/g,
            /dangerouslySetInnerHTML/g,
            /process\.exit\s*\(/g,
            /child_process/g,
            /\.exec\s*\(/g
        ];

        const suspiciousFiles = [];
        const allFiles = await this.getAllFiles(this.config.targetDir, ['.js', '.jsx', '.ts', '.tsx']);

        for (const filePath of allFiles) {
            const content = fs.readFileSync(filePath, 'utf8');
            const relativePath = path.relative(this.config.targetDir, filePath);

            for (const pattern of suspiciousPatterns) {
                const matches = content.match(pattern);
                if (matches) {
                    suspiciousFiles.push({
                        file: relativePath,
                        pattern: pattern.source,
                        matches: matches.length
                    });
                }
            }
        }

        return {
            passed: suspiciousFiles.length === 0,
            message: suspiciousFiles.length > 0 ?
                `å‘ç° ${suspiciousFiles.length} ä¸ªå¯ç–‘ä»£ç æ¨¡å¼` :
                'æœªå‘ç°å¯ç–‘ä»£ç æ¨¡å¼',
            details: suspiciousFiles
        };
    }

    async checkDependencySafety() {
        const packagePath = path.join(this.config.targetDir, 'package.json');

        if (!fs.existsSync(packagePath)) {
            return { passed: true, message: 'æ²¡æœ‰package.jsonï¼Œè·³è¿‡ä¾èµ–æ£€æŸ¥' };
        }

        try {
            const packageContent = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
            const allDeps = {
                ...packageContent.dependencies,
                ...packageContent.devDependencies
            };

            // æ£€æŸ¥å·²çŸ¥çš„å±é™©åŒ…
            const dangerousPackages = ['eval', 'vm2', 'node-uuid'];
            const foundDangerous = [];

            for (const pkg of dangerousPackages) {
                if (allDeps[pkg]) {
                    foundDangerous.push(pkg);
                }
            }

            return {
                passed: foundDangerous.length === 0,
                message: foundDangerous.length > 0 ?
                    `å‘ç°æ½œåœ¨å±é™©çš„ä¾èµ–: ${foundDangerous.join(', ')}` :
                    'ä¾èµ–å®‰å…¨æ£€æŸ¥é€šè¿‡',
                details: foundDangerous
            };

        } catch (error) {
            return { passed: false, message: `ä¾èµ–æ£€æŸ¥å¤±è´¥: ${error.message}` };
        }
    }

    async checkForSecrets() {
        const secretPatterns = [
            { name: 'API Keys', pattern: /['"]\w*api[_-]?key\w*['"]:\s*['"][^'"]{20,}['"]/gi },
            { name: 'Passwords', pattern: /['"]\w*password\w*['"]:\s*['"][^'"]{8,}['"]/gi },
            { name: 'Tokens', pattern: /['"]\w*token\w*['"]:\s*['"][^'"]{20,}['"]/gi },
            { name: 'Private Keys', pattern: /-----BEGIN [A-Z ]+PRIVATE KEY-----/gi },
            { name: 'Database URLs', pattern: /['"]\w*(?:database|db)_?url\w*['"]:\s*['"][^'"]{20,}['"]/gi }
        ];

        const secretsFound = [];
        const allFiles = await this.getAllFiles(this.config.targetDir, ['.js', '.jsx', '.ts', '.tsx', '.json', '.env']);

        for (const filePath of allFiles) {
            const content = fs.readFileSync(filePath, 'utf8');
            const relativePath = path.relative(this.config.targetDir, filePath);

            for (const { name, pattern } of secretPatterns) {
                const matches = content.match(pattern);
                if (matches) {
                    secretsFound.push({
                        file: relativePath,
                        type: name,
                        count: matches.length
                    });
                }
            }
        }

        return {
            passed: secretsFound.length === 0,
            message: secretsFound.length > 0 ?
                `å‘ç°æ½œåœ¨çš„æ•æ„Ÿä¿¡æ¯: ${secretsFound.length} å¤„` :
                'æœªå‘ç°æ•æ„Ÿä¿¡æ¯æ³„éœ²',
            details: secretsFound
        };
    }

    async checkFilePermissions() {
        const issues = [];
        const allFiles = await this.getAllFiles(this.config.targetDir);

        for (const filePath of allFiles) {
            try {
                const stats = fs.statSync(filePath);
                const mode = stats.mode & parseInt('777', 8);

                // æ£€æŸ¥æ˜¯å¦æœ‰æ‰§è¡Œæƒé™ï¼ˆå¯¹äºéè„šæœ¬æ–‡ä»¶ï¼‰
                const ext = path.extname(filePath);
                if (!['.sh', '.py', '.pl'].includes(ext) && (mode & parseInt('111', 8))) {
                    issues.push({
                        file: path.relative(this.config.targetDir, filePath),
                        issue: 'éè„šæœ¬æ–‡ä»¶å…·æœ‰æ‰§è¡Œæƒé™'
                    });
                }
            } catch (error) {
                // æƒé™æ£€æŸ¥å¤±è´¥ï¼Œè·³è¿‡
            }
        }

        return {
            passed: issues.length === 0,
            message: issues.length > 0 ?
                `å‘ç° ${issues.length} ä¸ªæƒé™é—®é¢˜` :
                'æ–‡ä»¶æƒé™æ£€æŸ¥é€šè¿‡',
            details: issues
        };
    }

    async checkPathTraversal() {
        const dangerousPatterns = [
            /\.\.\//g,
            /\.\.\\\\g,
            /__dirname.*\.\./g,
            /__filename.*\.\./g,
            /process\.cwd\(\).*\.\./g
        ];

        const issues = [];
        const allFiles = await this.getAllFiles(this.config.targetDir, ['.js', '.jsx', '.ts', '.tsx']);

        for (const filePath of allFiles) {
            const content = fs.readFileSync(filePath, 'utf8');
            const relativePath = path.relative(this.config.targetDir, filePath);

            for (const pattern of dangerousPatterns) {
                const matches = content.match(pattern);
                if (matches) {
                    issues.push({
                        file: relativePath,
                        pattern: pattern.source,
                        matches: matches.length
                    });
                }
            }
        }

        return {
            passed: issues.length === 0,
            message: issues.length > 0 ?
                `å‘ç°æ½œåœ¨çš„è·¯å¾„éå†é£é™©: ${issues.length} å¤„` :
                'è·¯å¾„éå†æ£€æŸ¥é€šè¿‡',
            details: issues
        };
    }

    // é˜¶æ®µ4: æ„å»ºæµ‹è¯•
    async performBuildTest() {
        console.log('\nğŸ”¨ é˜¶æ®µ4: é¡¹ç›®æ„å»ºæµ‹è¯•');

        const packagePath = path.join(this.config.targetDir, 'package.json');
        if (!fs.existsSync(packagePath)) {
            console.log('â­ï¸  æ²¡æœ‰package.jsonï¼Œè·³è¿‡æ„å»ºæµ‹è¯•');
            this.validationResults.buildTest.success = true;
            return;
        }

        try {
            const startTime = new Date();

            // é¦–å…ˆå®‰è£…ä¾èµ–
            console.log('ğŸ“¦ å®‰è£…ä¾èµ–...');
            await this.runCommand('npm', ['install'], { cwd: this.config.targetDir });

            // å°è¯•æ„å»ºé¡¹ç›®
            console.log('ğŸ”¨ æ„å»ºé¡¹ç›®...');
            const buildResult = await this.runCommand('npm', ['run', 'build'], {
                cwd: this.config.targetDir,
                timeout: 120000 // 2åˆ†é’Ÿè¶…æ—¶
            });

            this.validationResults.buildTest.success = true;
            this.validationResults.buildTest.output = buildResult.stdout;
            this.validationResults.buildTest.duration = new Date() - startTime;

            console.log('âœ… é¡¹ç›®æ„å»ºæˆåŠŸ');

        } catch (error) {
            this.validationResults.buildTest.success = false;
            this.validationResults.buildTest.errors.push(error.message);
            this.validationResults.buildTest.output = error.stdout || '';

            console.log(`âŒ é¡¹ç›®æ„å»ºå¤±è´¥: ${error.message}`);

            if (this.config.strictMode) {
                throw new Error(`æ„å»ºæµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }
    }

    async runCommand(command, args, options = {}) {
        return new Promise((resolve, reject) => {
            const child = spawn(command, args, {
                stdio: 'pipe',
                ...options
            });

            let stdout = '';
            let stderr = '';

            child.stdout.on('data', (data) => {
                stdout += data.toString();
            });

            child.stderr.on('data', (data) => {
                stderr += data.toString();
            });

            // è®¾ç½®è¶…æ—¶
            const timeout = setTimeout(() => {
                child.kill();
                reject(new Error(`å‘½ä»¤è¶…æ—¶: ${command} ${args.join(' ')}`));
            }, options.timeout || 60000);

            child.on('close', (code) => {
                clearTimeout(timeout);

                if (code === 0) {
                    resolve({ stdout, stderr, code });
                } else {
                    const error = new Error(`å‘½ä»¤å¤±è´¥: ${command} ${args.join(' ')} (exit code: ${code})`);
                    error.stdout = stdout;
                    error.stderr = stderr;
                    reject(error);
                }
            });

            child.on('error', (error) => {
                clearTimeout(timeout);
                reject(error);
            });
        });
    }

    // é˜¶æ®µ5: ç”Ÿæˆæœ€ç»ˆè¯„ä¼°
    generateFinalAssessment() {
        console.log('\nğŸ“Š ç”Ÿæˆæœ€ç»ˆè¯„ä¼°...');

        const scores = {
            fileIntegrity: this.calculateIntegrityScore(),
            projectStructure: this.calculateStructureScore(),
            security: this.calculateSecurityScore(),
            buildTest: this.calculateBuildScore()
        };

        const overallScore = Object.values(scores).reduce((sum, score) => sum + score, 0) / Object.keys(scores).length;

        // ç¡®å®šæ•´ä½“çŠ¶æ€
        if (overallScore >= 90) {
            this.validationResults.overallStatus = 'excellent';
        } else if (overallScore >= 75) {
            this.validationResults.overallStatus = 'good';
        } else if (overallScore >= 60) {
            this.validationResults.overallStatus = 'acceptable';
        } else {
            this.validationResults.overallStatus = 'poor';
        }

        this.validationResults.scores = scores;
        this.validationResults.overallScore = overallScore;

        // ç”Ÿæˆå»ºè®®
        this.generateRecommendations();

        console.log('ğŸ“ˆ è¯„ä¼°ç»“æœ:');
        console.log(`   æ–‡ä»¶å®Œæ•´æ€§: ${scores.fileIntegrity.toFixed(1)}%`);
        console.log(`   é¡¹ç›®ç»“æ„: ${scores.projectStructure.toFixed(1)}%`);
        console.log(`   å®‰å…¨æ£€æŸ¥: ${scores.security.toFixed(1)}%`);
        console.log(`   æ„å»ºæµ‹è¯•: ${scores.buildTest.toFixed(1)}%`);
        console.log(`   ğŸ“Š æ€»ä½“è¯„åˆ†: ${overallScore.toFixed(1)}% (${this.validationResults.overallStatus.toUpperCase()})`);
    }

    calculateIntegrityScore() {
        const total = this.validationResults.fileIntegrity.passed.length +
                     this.validationResults.fileIntegrity.failed.length;

        if (total === 0) return 0;

        return (this.validationResults.fileIntegrity.passed.length / total) * 100;
    }

    calculateStructureScore() {
        if (this.validationResults.projectStructure.valid) {
            const warningCount = this.validationResults.projectStructure.issues.filter(i => i.severity === 'warning').length;
            return Math.max(70, 100 - warningCount * 10); // æ¯ä¸ªè­¦å‘Šæ‰£10åˆ†ï¼Œæœ€ä½70åˆ†
        }
        return 40; // ç»“æ„æ— æ•ˆï¼Œç»™åŸºç¡€åˆ†
    }

    calculateSecurityScore() {
        const failedCount = this.validationResults.securityChecks.failed.length;
        const warningCount = this.validationResults.securityChecks.warnings.length;

        if (failedCount > 0) {
            return Math.max(0, 50 - failedCount * 25); // æ¯ä¸ªä¸¥é‡é—®é¢˜æ‰£25åˆ†
        }

        return Math.max(80, 100 - warningCount * 5); // æ¯ä¸ªè­¦å‘Šæ‰£5åˆ†ï¼Œæœ€ä½80åˆ†
    }

    calculateBuildScore() {
        if (!this.config.testProject) {
            return 85; // å¦‚æœæ²¡æœ‰æµ‹è¯•æ„å»ºï¼Œç»™é»˜è®¤åˆ†æ•°
        }

        return this.validationResults.buildTest.success ? 100 : 0;
    }

    generateRecommendations() {
        const recommendations = [];

        // åŸºäºæ–‡ä»¶å®Œæ•´æ€§çš„å»ºè®®
        if (this.validationResults.fileIntegrity.failed.length > 0) {
            recommendations.push({
                priority: 'high',
                category: 'file_integrity',
                message: `ä¿®å¤ ${this.validationResults.fileIntegrity.failed.length} ä¸ªæ–‡ä»¶å®Œæ•´æ€§é—®é¢˜`,
                details: this.validationResults.fileIntegrity.failed.map(f => f.error)
            });
        }

        // åŸºäºå®‰å…¨æ£€æŸ¥çš„å»ºè®®
        if (this.validationResults.securityChecks.failed.length > 0) {
            recommendations.push({
                priority: 'high',
                category: 'security',
                message: `è§£å†³ ${this.validationResults.securityChecks.failed.length} ä¸ªå®‰å…¨é—®é¢˜`,
                details: this.validationResults.securityChecks.failed.map(f => f.message)
            });
        }

        // åŸºäºé¡¹ç›®ç»“æ„çš„å»ºè®®
        if (!this.validationResults.projectStructure.valid) {
            recommendations.push({
                priority: 'medium',
                category: 'structure',
                message: 'ä¿®å¤é¡¹ç›®ç»“æ„é—®é¢˜',
                details: this.validationResults.projectStructure.issues.map(i => i.message)
            });
        }

        // åŸºäºæ„å»ºæµ‹è¯•çš„å»ºè®®
        if (!this.validationResults.buildTest.success && this.config.testProject) {
            recommendations.push({
                priority: 'high',
                category: 'build',
                message: 'ä¿®å¤æ„å»ºé”™è¯¯',
                details: this.validationResults.buildTest.errors
            });
        }

        // åŸºäºæ•´ä½“è¯„åˆ†çš„å»ºè®®
        if (this.validationResults.overallScore < 75) {
            recommendations.push({
                priority: 'medium',
                category: 'general',
                message: 'é¡¹ç›®è´¨é‡éœ€è¦æ”¹è¿›ï¼Œå»ºè®®è¿›è¡Œå…¨é¢æ£€æŸ¥å’Œä¼˜åŒ–'
            });
        }

        this.validationResults.recommendations = recommendations;
    }

    // é˜¶æ®µ6: ç”ŸæˆéªŒè¯æŠ¥å‘Š
    async generateValidationReport() {
        console.log('\nğŸ“„ ç”ŸæˆéªŒè¯æŠ¥å‘Š...');

        const report = {
            metadata: {
                timestamp: new Date().toISOString(),
                version: '1.0.0',
                workspaceDir: this.config.workspaceDir,
                targetDir: this.config.targetDir,
                configuration: this.config
            },
            summary: {
                overallStatus: this.validationResults.overallStatus,
                overallScore: this.validationResults.overallScore,
                scores: this.validationResults.scores,
                totalFiles: this.validationResults.fileIntegrity.passed.length +
                           this.validationResults.fileIntegrity.failed.length,
                passedFiles: this.validationResults.fileIntegrity.passed.length,
                securityIssues: this.validationResults.securityChecks.failed.length,
                buildSuccess: this.validationResults.buildTest.success
            },
            results: this.validationResults,
            recommendations: this.validationResults.recommendations
        };

        // ç”ŸæˆJSONæŠ¥å‘Š
        const jsonReportPath = path.join(this.config.workspaceDir, 'validation-report.json');
        fs.writeFileSync(jsonReportPath, JSON.stringify(report, null, 2));

        // ç”ŸæˆMarkdownæŠ¥å‘Š
        await this.generateMarkdownReport(report);

        // ç”ŸæˆHTMLæŠ¥å‘Š
        await this.generateHtmlReport(report);

        console.log('ğŸ“„ æŠ¥å‘Šæ–‡ä»¶å·²ç”Ÿæˆ:');
        console.log(`   ğŸ“Š JSONæŠ¥å‘Š: validation-report.json`);
        console.log(`   ğŸ“‹ MarkdownæŠ¥å‘Š: VALIDATION_REPORT.md`);
        console.log(`   ğŸŒ HTMLæŠ¥å‘Š: validation-report.html`);

        return report;
    }

    async generateMarkdownReport(report) {
        let markdown = '# ğŸ”’ å®‰å…¨éªŒè¯å’Œæµ‹è¯•æŠ¥å‘Š\n\n';

        markdown += `**éªŒè¯æ—¶é—´**: ${new Date(report.metadata.timestamp).toLocaleString()}\n`;
        markdown += `**ç›®æ ‡ç›®å½•**: ${report.metadata.targetDir}\n`;
        markdown += `**æ•´ä½“çŠ¶æ€**: ${this.getStatusIcon(report.summary.overallStatus)} ${report.summary.overallStatus.toUpperCase()}\n`;
        markdown += `**ç»¼åˆè¯„åˆ†**: ${report.summary.overallScore.toFixed(1)}/100\n\n`;

        markdown += '## ğŸ“Š è¯„åˆ†è¯¦æƒ…\n';
        Object.entries(report.summary.scores).forEach(([category, score]) => {
            markdown += `- **${category}**: ${score.toFixed(1)}%\n`;
        });
        markdown += '\n';

        markdown += '## ğŸ“‹ éªŒè¯ç»“æœæ‘˜è¦\n';
        markdown += `- ğŸ“ æ€»æ–‡ä»¶æ•°: ${report.summary.totalFiles}\n`;
        markdown += `- âœ… é€šè¿‡æ–‡ä»¶: ${report.summary.passedFiles}\n`;
        markdown += `- ğŸ”’ å®‰å…¨é—®é¢˜: ${report.summary.securityIssues}\n`;
        markdown += `- ğŸ”¨ æ„å»ºçŠ¶æ€: ${report.summary.buildSuccess ? 'âœ… æˆåŠŸ' : 'âŒ å¤±è´¥'}\n\n`;

        // æ–‡ä»¶å®Œæ•´æ€§è¯¦æƒ…
        markdown += '## ğŸ“ æ–‡ä»¶å®Œæ•´æ€§æ£€æŸ¥\n';
        if (this.validationResults.fileIntegrity.failed.length > 0) {
            markdown += '### âŒ å¤±è´¥çš„æ–‡ä»¶\n';
            this.validationResults.fileIntegrity.failed.forEach(failure => {
                markdown += `- **${failure.file}**: ${failure.error}\n`;
            });
            markdown += '\n';
        } else {
            markdown += 'âœ… æ‰€æœ‰æ–‡ä»¶å®Œæ•´æ€§æ£€æŸ¥é€šè¿‡\n\n';
        }

        // å®‰å…¨æ£€æŸ¥è¯¦æƒ…
        markdown += '## ğŸ”’ å®‰å…¨æ£€æŸ¥ç»“æœ\n';
        if (this.validationResults.securityChecks.failed.length > 0) {
            markdown += '### âŒ ä¸¥é‡å®‰å…¨é—®é¢˜\n';
            this.validationResults.securityChecks.failed.forEach(issue => {
                markdown += `- **${issue.name}**: ${issue.message}\n`;
                if (issue.details && issue.details.length > 0) {
                    issue.details.forEach(detail => {
                        markdown += `  - ${JSON.stringify(detail)}\n`;
                    });
                }
            });
            markdown += '\n';
        }

        if (this.validationResults.securityChecks.warnings.length > 0) {
            markdown += '### âš ï¸ å®‰å…¨è­¦å‘Š\n';
            this.validationResults.securityChecks.warnings.forEach(warning => {
                markdown += `- **${warning.name}**: ${warning.message}\n`;
            });
            markdown += '\n';
        }

        if (this.validationResults.securityChecks.failed.length === 0 &&
            this.validationResults.securityChecks.warnings.length === 0) {
            markdown += 'âœ… æ‰€æœ‰å®‰å…¨æ£€æŸ¥é€šè¿‡\n\n';
        }

        // é¡¹ç›®ç»“æ„
        markdown += '## ğŸ—ï¸ é¡¹ç›®ç»“æ„éªŒè¯\n';
        if (this.validationResults.projectStructure.issues.length > 0) {
            this.validationResults.projectStructure.issues.forEach(issue => {
                const icon = issue.severity === 'error' ? 'âŒ' : 'âš ï¸';
                markdown += `${icon} **${issue.rule}**: ${issue.message}\n`;
            });
            markdown += '\n';
        } else {
            markdown += 'âœ… é¡¹ç›®ç»“æ„éªŒè¯é€šè¿‡\n\n';
        }

        // æ¨èæ“ä½œ
        if (report.recommendations.length > 0) {
            markdown += '## ğŸš€ æ¨èæ“ä½œ\n';
            report.recommendations.forEach((rec, index) => {
                const priority = rec.priority === 'high' ? 'ğŸ”¥' :
                               rec.priority === 'medium' ? 'âš¡' : 'ğŸ“';
                markdown += `${index + 1}. ${priority} **${rec.category}**: ${rec.message}\n`;
                if (rec.details && rec.details.length > 0) {
                    rec.details.forEach(detail => {
                        markdown += `   - ${detail}\n`;
                    });
                }
                markdown += '\n';
            });
        }

        const reportPath = path.join(this.config.workspaceDir, 'VALIDATION_REPORT.md');
        fs.writeFileSync(reportPath, markdown);
    }

    async generateHtmlReport(report) {
        const html = `
<!DOCTYPE html>
<html>
<head>
    <title>å®‰å…¨éªŒè¯å’Œæµ‹è¯•æŠ¥å‘Š</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .header { text-align: center; margin-bottom: 30px; }
        .status-excellent { color: #4caf50; }
        .status-good { color: #8bc34a; }
        .status-acceptable { color: #ff9800; }
        .status-poor { color: #f44336; }
        .score-card { display: inline-block; margin: 10px; padding: 15px; background: #f8f9fa; border-radius: 5px; text-align: center; }
        .score-value { font-size: 24px; font-weight: bold; }
        .issue { margin: 10px 0; padding: 10px; border-left: 4px solid #ccc; background: #f9f9f9; }
        .issue.error { border-color: #f44336; }
        .issue.warning { border-color: #ff9800; }
        .recommendation { margin: 10px 0; padding: 15px; background: #e3f2fd; border-radius: 4px; }
        .files-list { max-height: 300px; overflow-y: auto; background: #f5f5f5; padding: 15px; border-radius: 4px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”’ å®‰å…¨éªŒè¯å’Œæµ‹è¯•æŠ¥å‘Š</h1>
            <p><strong>éªŒè¯æ—¶é—´:</strong> ${new Date(report.metadata.timestamp).toLocaleString()}</p>
            <p><strong>ç›®æ ‡ç›®å½•:</strong> ${report.metadata.targetDir}</p>
            <h2 class="status-${report.summary.overallStatus}">
                çŠ¶æ€: ${report.summary.overallStatus.toUpperCase()}
                (${report.summary.overallScore.toFixed(1)}/100)
            </h2>
        </div>

        <h2>ğŸ“Š è¯„åˆ†è¯¦æƒ…</h2>
        <div>
            ${Object.entries(report.summary.scores).map(([category, score]) => `
                <div class="score-card">
                    <div class="score-value">${score.toFixed(1)}%</div>
                    <div>${category}</div>
                </div>
            `).join('')}
        </div>

        <h2>ğŸ“‹ éªŒè¯ç»“æœæ‘˜è¦</h2>
        <table>
            <tr><th>æŒ‡æ ‡</th><th>ç»“æœ</th></tr>
            <tr><td>æ€»æ–‡ä»¶æ•°</td><td>${report.summary.totalFiles}</td></tr>
            <tr><td>é€šè¿‡æ–‡ä»¶</td><td>${report.summary.passedFiles}</td></tr>
            <tr><td>å®‰å…¨é—®é¢˜</td><td>${report.summary.securityIssues}</td></tr>
            <tr><td>æ„å»ºçŠ¶æ€</td><td>${report.summary.buildSuccess ? 'âœ… æˆåŠŸ' : 'âŒ å¤±è´¥'}</td></tr>
        </table>

        ${this.validationResults.securityChecks.failed.length > 0 ? `
        <h2>âŒ å®‰å…¨é—®é¢˜</h2>
        ${this.validationResults.securityChecks.failed.map(issue => `
            <div class="issue error">
                <strong>${issue.name}</strong>: ${issue.message}
            </div>
        `).join('')}
        ` : ''}

        ${report.recommendations.length > 0 ? `
        <h2>ğŸš€ æ¨èæ“ä½œ</h2>
        ${report.recommendations.map((rec, index) => `
            <div class="recommendation">
                <strong>${index + 1}. ${rec.category}</strong>: ${rec.message}
                ${rec.details ? `<ul>${rec.details.map(detail => `<li>${detail}</li>`).join('')}</ul>` : ''}
            </div>
        `).join('')}
        ` : ''}

        <h2>ğŸ“ æ–‡ä»¶åˆ—è¡¨</h2>
        <div class="files-list">
            ${this.validationResults.fileIntegrity.passed.map(file =>
                `<div>âœ… ${path.relative(this.config.targetDir, file)}</div>`
            ).join('')}
            ${this.validationResults.fileIntegrity.failed.map(failure =>
                `<div>âŒ ${failure.file} - ${failure.error}</div>`
            ).join('')}
        </div>
    </div>
</body>
</html>`;

        const reportPath = path.join(this.config.workspaceDir, 'validation-report.html');
        fs.writeFileSync(reportPath, html);
    }

    getStatusIcon(status) {
        const icons = {
            excellent: 'ğŸŒŸ',
            good: 'âœ…',
            acceptable: 'âš ï¸',
            poor: 'âŒ'
        };
        return icons[status] || 'â“';
    }

    // è¾…åŠ©æ–¹æ³•
    async getAllFiles(dirPath, extensions = null) {
        const files = [];

        const scanDirectory = (currentPath) => {
            const items = fs.readdirSync(currentPath);

            for (const item of items) {
                const itemPath = path.join(currentPath, item);
                const stats = fs.statSync(itemPath);

                if (stats.isDirectory()) {
                    // è·³è¿‡node_modulesç­‰ç›®å½•
                    if (!['node_modules', '.git', '.next', 'dist', 'build'].includes(item)) {
                        scanDirectory(itemPath);
                    }
                } else if (stats.isFile()) {
                    if (!extensions || extensions.includes(path.extname(item))) {
                        files.push(itemPath);
                    }
                }
            }
        };

        scanDirectory(dirPath);
        return files;
    }

    async calculateFileChecksum(filePath) {
        return new Promise((resolve, reject) => {
            const hash = crypto.createHash('sha256');
            const stream = fs.createReadStream(filePath);

            stream.on('data', data => hash.update(data));
            stream.on('end', () => resolve(hash.digest('hex')));
            stream.on('error', reject);
        });
    }
}

// ä½¿ç”¨ç¤ºä¾‹å’ŒCLIæ¥å£
async function main() {
    const args = process.argv.slice(2);

    const config = {
        workspaceDir: './recovery-workspace',
        targetDir: '../recovered',
        validateChecksums: !args.includes('--no-checksums'),
        testProject: !args.includes('--no-build'),
        generateReport: !args.includes('--no-report'),
        strictMode: args.includes('--strict')
    };

    try {
        console.log('ğŸ”’ å¯åŠ¨å®‰å…¨éªŒè¯å’Œæµ‹è¯•ç³»ç»Ÿ');

        const validator = new SafetyValidationSystem(config);
        const results = await validator.validate();

        console.log(`\nğŸ‰ éªŒè¯å®Œæˆï¼æ•´ä½“çŠ¶æ€: ${results.overallStatus.toUpperCase()}`);
        console.log(`ğŸ“Š ç»¼åˆè¯„åˆ†: ${results.overallScore.toFixed(1)}/100`);

        if (results.recommendations.length > 0) {
            console.log(`\nğŸ“‹ å‘ç° ${results.recommendations.length} æ¡æ”¹è¿›å»ºè®®ï¼Œè¯¦è§éªŒè¯æŠ¥å‘Š`);
        }

        // æ ¹æ®ç»“æœè®¾ç½®é€€å‡ºä»£ç 
        if (results.overallStatus === 'poor' ||
            (config.strictMode && results.overallScore < 80)) {
            process.exit(1);
        } else {
            process.exit(0);
        }

    } catch (error) {
        console.error('\nâŒ éªŒè¯ç³»ç»Ÿæ‰§è¡Œå¤±è´¥:', error.message);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}

module.exports = SafetyValidationSystem;


ä»»åŠ¡9ï¼šé›†æˆå·¥ä½œæµç³»ç»Ÿå®Œæˆå¾—éå¸¸å‡ºè‰²ï¼æ‚¨æ„å»ºäº†ä¸€ä¸ªä¼ä¸šçº§çš„å·¥ä½œæµorchestratorï¼Œå®ç°äº†åæ­¥éª¤å®Œæ•´æµç¨‹å’Œä¸‰ç§æ‰§è¡Œæ¨¡å¼ã€‚æµ‹è¯•ç»“æœæ˜¾ç¤ºç³»ç»Ÿèƒ½å¤Ÿæ­£ç¡®å¤„ç†55ä¸ªmiscæ–‡ä»¶å¹¶æä¾›å®Œæ•´çš„è¿›åº¦è·Ÿè¸ªã€‚
ç°åœ¨è®©æˆ‘ä»¬å®Œæˆæœ€åä¸€ä¸ªä»»åŠ¡10ï¼šå®‰å…¨éªŒè¯ç³»ç»Ÿã€‚è¿™å°†ç¡®ä¿æ•´ä¸ªæ¢å¤æµç¨‹çš„å®Œæ•´æ€§å’Œå¯é æ€§ã€‚


ğŸ‰ **ä»»åŠ¡10ï¼šå®‰å…¨éªŒè¯å’Œæµ‹è¯•ç³»ç»Ÿå·²å®Œæˆï¼**

è¿™æ˜¯ä¸€ä¸ªå…¨é¢çš„å®‰å…¨éªŒè¯å’Œæµ‹è¯•ç³»ç»Ÿï¼Œæä¾›ä¼ä¸šçº§çš„è´¨é‡ä¿è¯å’Œå®‰å…¨æ£€æŸ¥åŠŸèƒ½ï¼š

### æ ¸å¿ƒéªŒè¯èƒ½åŠ›
- **æ–‡ä»¶å®Œæ•´æ€§æ£€æŸ¥**: SHA256æ ¡éªŒå’Œã€è¯­æ³•éªŒè¯ã€æ‰©å±•åæ£€æŸ¥
- **é¡¹ç›®ç»“æ„éªŒè¯**: package.jsonã€Next.jsé…ç½®ã€TypeScripté…ç½®ã€ç›®å½•ç»“æ„
- **å…¨é¢å®‰å…¨æ‰«æ**: æ¶æ„ä»£ç æ£€æµ‹ã€ä¾èµ–å®‰å…¨ã€æ•æ„Ÿä¿¡æ¯æ³„éœ²ã€æƒé™æ£€æŸ¥
- **æ„å»ºæµ‹è¯•**: è‡ªåŠ¨npm installå’Œbuildæµ‹è¯•ï¼Œæ”¯æŒè¶…æ—¶æ§åˆ¶

### æ™ºèƒ½è¯„åˆ†ç³»ç»Ÿ
- **å¤šç»´åº¦è¯„åˆ†**: æ–‡ä»¶å®Œæ•´æ€§ã€é¡¹ç›®ç»“æ„ã€å®‰å…¨æ€§ã€æ„å»ºæµ‹è¯•å››ä¸ªç»´åº¦
- **æ™ºèƒ½æƒé‡**: ä¸¥é‡é—®é¢˜æ‰£åˆ†æ›´å¤šï¼Œè­¦å‘Šå½±å“è¾ƒå°
- **çŠ¶æ€åˆ†çº§**: Excellent (90+) â†’ Good (75+) â†’ Acceptable (60+) â†’ Poor (<60)

### å®Œæ•´æŠ¥å‘Šç”Ÿæˆ
- **ä¸‰ç§æ ¼å¼**: JSONæ•°æ®æŠ¥å‘Šã€Markdownå¯è¯»æŠ¥å‘Šã€HTMLå¯è§†åŒ–æŠ¥å‘Š
- **è¯¦ç»†åˆ†æ**: é—®é¢˜å®šä½ã€æ”¹è¿›å»ºè®®ã€ä¼˜å…ˆçº§æ’åº
- **å¯è§†åŒ–å±•ç¤º**: è¯„åˆ†å¡ã€é—®é¢˜åˆ—è¡¨ã€æ–‡ä»¶çŠ¶æ€ä¸€ç›®äº†ç„¶

## ğŸ¯ å®Œæ•´çš„åä»»åŠ¡ç³»ç»Ÿç°å·²å…¨éƒ¨å®Œæˆï¼

è®©æˆ‘ä»¬å›é¡¾è¿™ä¸ªä¼ä¸šçº§æ–‡ä»¶æ¢å¤ç³»ç»Ÿçš„å®Œæ•´æ¶æ„ï¼š

### ğŸ“Š å®Œæˆçš„åå¤§ç³»ç»Ÿæ¨¡å—ï¼š
1. âœ… **ç¯å¢ƒè®¾ç½®** - å·¥ä½œç¯å¢ƒéªŒè¯å’Œåˆå§‹åŒ–
2. âœ… **æ–‡ä»¶æ”¶é›†** - è‡ªåŠ¨å‘ç°å’ŒéªŒè¯miscæ–‡ä»¶
3. âœ… **å†…å®¹åˆ†æ** - AIé©±åŠ¨çš„æ·±åº¦å†…å®¹åˆ†æ
4. âœ… **è‡ªåŠ¨åˆ†ç±»** - æ™ºèƒ½æ–‡ä»¶åˆ†ç±»å’Œå»é‡ç³»ç»Ÿ
5. âœ… **æ–‡ä»¶åå»ºè®®** - åŸºäºå†…å®¹çš„æ™ºèƒ½å‘½åå¼•æ“
6. âœ… **æ‰‹åŠ¨å®¡æŸ¥** - äº¤äº’å¼æ–‡ä»¶å®¡æŸ¥ç•Œé¢
7. âœ… **å®‰å…¨æ¢å¤** - å¤šé‡ä¿æŠ¤çš„æ¢å¤ç³»ç»Ÿ
8. âœ… **æ—¥å¿—æŠ¥å‘Š** - å…¨ç¨‹æ—¥å¿—è®°å½•å’ŒæŠ¥å‘Šç”Ÿæˆ
9. âœ… **é›†æˆå·¥ä½œæµ** - ç»Ÿä¸€çš„å·¥ä½œæµç¼–æ’ç³»ç»Ÿ
10. âœ… **å®‰å…¨éªŒè¯** - æœ€ç»ˆçš„è´¨é‡ä¿è¯å’Œå®‰å…¨æ£€æŸ¥

### ğŸš€ ä½¿ç”¨æ–¹å¼ï¼š
```bash
# å®Œæ•´å·¥ä½œæµæ‰§è¡Œ
node integrated-workflow-system.js

# å®‰å…¨éªŒè¯
node safety-validation-system.js

# ä¸¥æ ¼æ¨¡å¼éªŒè¯
node safety-validation-system.js --strict
```

è¿™ä¸ªå®Œæ•´çš„ç³»ç»Ÿç°åœ¨å¯ä»¥å¤„ç†æ‚¨çš„55ä¸ªmiscæ–‡ä»¶ï¼Œä»åˆ†æåˆ°æœ€ç»ˆéªŒè¯çš„æ•´ä¸ªæ¢å¤æµç¨‹ã€‚æ¯ä¸ªç»„ä»¶éƒ½ç»è¿‡æµ‹è¯•éªŒè¯ï¼Œå…·å¤‡ä¼ä¸šçº§çš„å¯é æ€§å’Œå®‰å…¨æ€§ã€‚

æ‚¨ç°åœ¨æ‹¥æœ‰äº†ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€å®‰å…¨å¯é çš„æ–‡ä»¶æ¢å¤è§£å†³æ–¹æ¡ˆï¼å‡†å¤‡å¼€å§‹ä½¿ç”¨è¿™ä¸ªç³»ç»Ÿæ¢å¤æ‚¨çš„é¡¹ç›®æ–‡ä»¶äº†å—ï¼Ÿ
