// æ™ºèƒ½å†…å®¹åˆ†æå¼•æ“ - ä¸“é—¨å¤„ç†VS Codeå´©æºƒæ¢å¤çš„miscæ–‡ä»¶
// file: recovery-workspace/advanced-analysis-engine.js

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class ContentAnalysisEngine {
    constructor(analysisDir, outputDir) {
        this.analysisDir = analysisDir;
        this.outputDir = outputDir;
        this.results = {
            totalFiles: 0,
            duplicates: [],
            versions: {},
            categories: {},
            pathInferences: {},
            timeline: []
        };
        
        // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
        this.ensureDirectories();
    }

    ensureDirectories() {
        const dirs = ['components', 'pages', 'api', 'utils', 'hooks', 'styles', 'config', 'types', 'lib', 'unknown'];
        dirs.forEach(dir => {
            fs.mkdirSync(path.join(this.outputDir, dir), { recursive: true });
        });
    }

    // 1. æ—¶é—´æˆ³åˆ†æ - ä»æ–‡ä»¶åå’Œå…ƒæ•°æ®ä¸­æå–æ—¶é—´ä¿¡æ¯
    extractTimestamp(filename, stats) {
        const patterns = [
            // misc-1693478400000.js (Unix timestamp)
            /misc-(\d{10,13})\./, 
            // misc-20230830-143000.js (YYYYMMDD-HHMMSS)
            /misc-(\d{8}-\d{6})\./,
            // misc-2023-08-30T14-30-00.js (ISO-like)
            /misc-(\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2})\./
        ];

        for (const pattern of patterns) {
            const match = filename.match(pattern);
            if (match) {
                const timeStr = match[1];
                if (timeStr.length >= 10) {
                    // Unix timestamp
                    const timestamp = parseInt(timeStr);
                    return new Date(timestamp > 9999999999 ? timestamp : timestamp * 1000);
                } else {
                    // å…¶ä»–æ ¼å¼å°è¯•è§£æ
                    try {
                        return new Date(timeStr.replace(/T/, ' ').replace(/-/g, ':'));
                    } catch (e) {
                        // ç»§ç»­å°è¯•å…¶ä»–æ–¹æ³•
                    }
                }
            }
        }

        // å¦‚æœæ–‡ä»¶åä¸­æ²¡æœ‰æ—¶é—´æˆ³ï¼Œä½¿ç”¨æ–‡ä»¶ä¿®æ”¹æ—¶é—´
        return stats.mtime;
    }

    // 2. å»é‡æ£€æµ‹ - åŸºäºå†…å®¹å“ˆå¸Œå’Œç›¸ä¼¼åº¦
    calculateContentHash(content) {
        // æ ‡å‡†åŒ–å†…å®¹ï¼šç§»é™¤ç©ºç™½å­—ç¬¦ã€æ³¨é‡Šç­‰
        const normalized = content
            .replace(/\/\*[\s\S]*?\*\//g, '') // ç§»é™¤å—æ³¨é‡Š
            .replace(/\/\/.*$/gm, '') // ç§»é™¤è¡Œæ³¨é‡Š
            .replace(/\s+/g, ' ') // æ ‡å‡†åŒ–ç©ºç™½
            .replace(/;?\s*$/gm, '') // ç§»é™¤è¡Œå°¾åˆ†å·å’Œç©ºç™½
            .trim();
        
        return crypto.createHash('md5').update(normalized).digest('hex');
    }

    calculateSimilarity(content1, content2) {
        // ç®€å•çš„ç›¸ä¼¼åº¦è®¡ç®— - åŸºäºè¡Œçš„Jaccardç›¸ä¼¼åº¦
        const lines1 = new Set(content1.split('\n').map(line => line.trim()).filter(line => line));
        const lines2 = new Set(content2.split('\n').map(line => line.trim()).filter(line => line));
        
        const intersection = new Set([...lines1].filter(line => lines2.has(line)));
        const union = new Set([...lines1, ...lines2]);
        
        return intersection.size / union.size;
    }

    // 3. å†…å®¹ç‰¹å¾åˆ†æ - æ›´ç²¾ç¡®çš„æ–‡ä»¶ç±»å‹è¯†åˆ«
    analyzeContentFeatures(content, filename) {
        const features = {
            type: 'unknown',
            subtype: null,
            confidence: 0,
            characteristics: [],
            imports: [],
            exports: [],
            functions: [],
            components: [],
            hooks: [],
            apiEndpoints: [],
            configKeys: []
        };

        // æå–imports
        const importMatches = content.match(/import\s+.*?from\s+['"`]([^'"`]+)['"`]/g);
        if (importMatches) {
            features.imports = importMatches.map(imp => {
                const match = imp.match(/from\s+['"`]([^'"`]+)['"`]/);
                return match ? match[1] : null;
            }).filter(Boolean);
        }

        // æå–exports
        const exportMatches = content.match(/export\s+(default\s+)?(function|const|class|interface|type)\s+(\w+)/g);
        if (exportMatches) {
            features.exports = exportMatches.map(exp => {
                const match = exp.match(/export\s+(?:default\s+)?(?:function|const|class|interface|type)\s+(\w+)/);
                return match ? match[1] : null;
            }).filter(Boolean);
        }

        // åˆ†ææ–‡ä»¶ç±»å‹
        const typeAnalysis = this.determineFileType(content, features);
        Object.assign(features, typeAnalysis);

        return features;
    }

    determineFileType(content, features) {
        const rules = {
            // Reactç»„ä»¶
            component: {
                patterns: [
                    /export\s+default\s+function\s+\w+/,
                    /export\s+default\s+\w+Component/,
                    /return\s*\(\s*<[^>]*>/,
                    /jsx|tsx/i,
                    /useState|useEffect|useContext|useReducer/
                ],
                imports: ['react', '@/', './'],
                weight: 1.0
            },
            
            // Next.jsé¡µé¢
            page: {
                patterns: [
                    /export\s+default\s+function\s+\w+Page/,
                    /getServerSideProps|getStaticProps|getStaticPaths/,
                    /next\/head|next\/router|next\/link/
                ],
                imports: ['next/', '@/'],
                weight: 0.9
            },

            // APIè·¯ç”±
            api: {
                patterns: [
                    /export\s+default\s+function\s+handler/,
                    /req\.method|res\.status|res\.json/,
                    /NextApiRequest|NextApiResponse/
                ],
                imports: ['next'],
                weight: 0.95
            },

            // å·¥å…·å‡½æ•°
            util: {
                patterns: [
                    /export\s+(const|function)\s+\w+/,
                    /export\s*{[^}]+}/,
                    /utils?|helpers?/i
                ],
                imports: [],
                weight: 0.6
            },

            // React Hooks
            hook: {
                patterns: [
                    /export\s+(const|function)\s+use\w+/,
                    /use[A-Z]\w+\(/,
                    /useState|useEffect|useCallback|useMemo/
                ],
                imports: ['react'],
                weight: 0.8
            },

            // é…ç½®æ–‡ä»¶
            config: {
                patterns: [
                    /export\s+default\s*{/,
                    /module\.exports\s*=/,
                    /process\.env/,
                    /config|Config/i
                ],
                imports: [],
                weight: 0.7
            },

            // TypeScriptç±»å‹å®šä¹‰
            types: {
                patterns: [
                    /interface\s+\w+\s*{/,
                    /type\s+\w+\s*=/,
                    /export\s+type|export\s+interface/,
                    /\.d\.ts$/
                ],
                imports: [],
                weight: 0.9
            },

            // æ ·å¼æ–‡ä»¶
            style: {
                patterns: [
                    /styled-components|emotion/,
                    /className|tailwind/i,
                    /\.module\.css|\.scss/,
                    /createGlobalStyle|css`/
                ],
                imports: ['styled-components', '@emotion'],
                weight: 0.8
            }
        };

        let bestMatch = { type: 'unknown', confidence: 0, characteristics: [] };

        Object.entries(rules).forEach(([type, rule]) => {
            let score = 0;
            let matches = [];

            // æ£€æŸ¥æ¨¡å¼åŒ¹é…
            rule.patterns.forEach(pattern => {
                if (pattern.test(content)) {
                    score += 0.3;
                    matches.push(`pattern: ${pattern.source}`);
                }
            });

            // æ£€æŸ¥importåŒ¹é…
            rule.imports.forEach(importPrefix => {
                if (features.imports.some(imp => imp.includes(importPrefix))) {
                    score += 0.2;
                    matches.push(`import: ${importPrefix}`);
                }
            });

            const confidence = (score * rule.weight).toFixed(2);
            if (confidence > bestMatch.confidence) {
                bestMatch = {
                    type,
                    confidence: parseFloat(confidence),
                    characteristics: matches
                };
            }
        });

        return bestMatch;
    }

    // 4. åŸå§‹è·¯å¾„æ¨æ–­ - åŸºäºå†…å®¹å’Œæ³¨é‡Šæ¨æ–­åŸå§‹ä½ç½®
    inferOriginalPath(content, features, filename) {
        const pathClues = [];

        // ä»æ³¨é‡Šä¸­å¯»æ‰¾è·¯å¾„çº¿ç´¢
        const commentPaths = content.match(/\/\/.*?(?:src\/|pages\/|components\/|utils\/|hooks\/|api\/)[^\s]*/g);
        if (commentPaths) {
            pathClues.push(...commentPaths.map(comment => comment.replace(/\/\/.*?(?=src\/|pages\/|components\/|utils\/|hooks\/|api\/)/, '')));
        }

        // ä»importè·¯å¾„æ¨æ–­
        if (features.imports.length > 0) {
            features.imports.forEach(imp => {
                if (imp.startsWith('./') || imp.startsWith('../')) {
                    pathClues.push(`relative import: ${imp}`);
                } else if (imp.startsWith('@/')) {
                    pathClues.push(`absolute import: ${imp}`);
                }
            });
        }

        // åŸºäºæ–‡ä»¶ç±»å‹æ¨æ–­ç›®å½•
        const typeToDir = {
            component: 'components',
            page: 'pages',
            api: 'pages/api',
            hook: 'hooks',
            util: 'utils',
            config: 'config',
            types: 'types',
            style: 'styles'
        };

        const suggestedDir = typeToDir[features.type] || 'unknown';

        // æ¨æ–­æ–‡ä»¶å
        let suggestedFilename = filename;
        
        // ä»exportä¸­æ¨æ–­
        if (features.exports.length > 0) {
            const mainExport = features.exports[0];
            const extension = filename.match(/\.(jsx?|tsx?)$/)?.[0] || '.js';
            suggestedFilename = `${mainExport}${extension}`;
        }

        // ä»å‡½æ•°åæ¨æ–­
        const functionMatch = content.match(/(?:export\s+default\s+)?function\s+(\w+)/);
        if (functionMatch && functionMatch[1] !== 'handler') {
            const extension = filename.match(/\.(jsx?|tsx?)$/)?.[0] || '.js';
            suggestedFilename = `${functionMatch[1]}${extension}`;
        }

        return {
            suggestedDir,
            suggestedFilename,
            fullPath: `${suggestedDir}/${suggestedFilename}`,
            pathClues,
            confidence: pathClues.length > 0 ? 0.8 : 0.5
        };
    }

    // ä¸»åˆ†æå‡½æ•°
    async analyze() {
        console.log('ğŸ” å¼€å§‹æ™ºèƒ½å†…å®¹åˆ†æ...\n');
        
        const files = fs.readdirSync(this.analysisDir)
            .filter(f => f.startsWith('misc-') && (f.endsWith('.js') || f.endsWith('.jsx') || f.endsWith('.ts') || f.endsWith('.tsx')))
            .sort();

        this.results.totalFiles = files.length;
        console.log(`ğŸ“ å‘ç° ${files.length} ä¸ªmiscæ–‡ä»¶\n`);

        const fileData = [];
        const contentHashes = new Map();

        // ç¬¬ä¸€éï¼šè¯»å–æ‰€æœ‰æ–‡ä»¶å¹¶è¿›è¡ŒåŸºç¡€åˆ†æ
        for (const filename of files) {
            const filepath = path.join(this.analysisDir, filename);
            const stats = fs.statSync(filepath);
            const content = fs.readFileSync(filepath, 'utf8');
            
            const timestamp = this.extractTimestamp(filename, stats);
            const contentHash = this.calculateContentHash(content);
            const features = this.analyzeContentFeatures(content, filename);
            const pathInference = this.inferOriginalPath(content, features, filename);

            const fileInfo = {
                filename,
                filepath,
                size: stats.size,
                timestamp,
                content,
                contentHash,
                features,
                pathInference,
                isDuplicate: false,
                versions: []
            };

            fileData.push(fileInfo);

            // æ£€æŸ¥é‡å¤
            if (contentHashes.has(contentHash)) {
                const existingFile = contentHashes.get(contentHash);
                fileInfo.isDuplicate = true;
                existingFile.versions.push(fileInfo);
                this.results.duplicates.push({
                    hash: contentHash,
                    files: [existingFile.filename, fileInfo.filename],
                    keepNewest: fileInfo.timestamp > existingFile.timestamp ? fileInfo.filename : existingFile.filename
                });
            } else {
                contentHashes.set(contentHash, fileInfo);
            }
        }

        // ç¬¬äºŒéï¼šç‰ˆæœ¬åˆ†æå’Œç›¸ä¼¼åº¦æ£€æµ‹
        console.log('ğŸ”„ è¿›è¡Œç‰ˆæœ¬åˆ†æå’Œç›¸ä¼¼åº¦æ£€æµ‹...\n');
        
        for (let i = 0; i < fileData.length; i++) {
            for (let j = i + 1; j < fileData.length; j++) {
                const file1 = fileData[i];
                const file2 = fileData[j];
                
                if (file1.contentHash !== file2.contentHash) {
                    const similarity = this.calculateSimilarity(file1.content, file2.content);
                    
                    if (similarity > 0.8) { // 80%ä»¥ä¸Šç›¸ä¼¼åº¦è®¤ä¸ºæ˜¯ç‰ˆæœ¬å…³ç³»
                        const versionGroup = `${file1.features.type}_${similarity.toFixed(2)}`;
                        
                        if (!this.results.versions[versionGroup]) {
                            this.results.versions[versionGroup] = [];
                        }
                        
                        this.results.versions[versionGroup].push({
                            files: [file1.filename, file2.filename],
                            similarity,
                            newerFile: file1.timestamp > file2.timestamp ? file1.filename : file2.filename,
                            type: file1.features.type
                        });
                    }
                }
            }
        }

        // ç”Ÿæˆåˆ†ç±»ç»Ÿè®¡
        fileData.forEach(file => {
            const type = file.features.type;
            if (!this.results.categories[type]) {
                this.results.categories[type] = [];
            }
            this.results.categories[type].push({
                filename: file.filename,
                confidence: file.features.confidence,
                suggestedPath: file.pathInference.fullPath,
                size: file.size,
                timestamp: file.timestamp
            });
        });

        // ç”Ÿæˆæ—¶é—´çº¿
        this.results.timeline = fileData
            .sort((a, b) => a.timestamp - b.timestamp)
            .map(file => ({
                timestamp: file.timestamp,
                filename: file.filename,
                type: file.features.type,
                action: 'recovered'
            }));

        return this.generateReport(fileData);
    }

    generateReport(fileData) {
        const report = {
            summary: {
                totalFiles: this.results.totalFiles,
                duplicateGroups: this.results.duplicates.length,
                versionGroups: Object.keys(this.results.versions).length,
                categories: Object.keys(this.results.categories).map(cat => ({
                    type: cat,
                    count: this.results.categories[cat].length,
                    avgConfidence: (this.results.categories[cat].reduce((sum, f) => sum + f.confidence, 0) / this.results.categories[cat].length).toFixed(2)
                }))
            },
            duplicates: this.results.duplicates,
            versions: this.results.versions,
            categories: this.results.categories,
            timeline: this.results.timeline,
            recommendations: this.generateRecommendations()
        };

        // ä¿å­˜è¯¦ç»†æŠ¥å‘Š
        fs.writeFileSync(path.join(this.outputDir, '../analysis-report.json'), JSON.stringify(report, null, 2));
        
        // ç”Ÿæˆäººç±»å¯è¯»çš„æŠ¥å‘Š
        this.generateHumanReadableReport(report);
        
        // ç”Ÿæˆæ¢å¤è„šæœ¬
        this.generateRecoveryScript(fileData);

        return report;
    }

    generateRecommendations() {
        const recommendations = [];

        // é‡å¤æ–‡ä»¶å¤„ç†å»ºè®®
        if (this.results.duplicates.length > 0) {
            recommendations.push({
                type: 'duplicates',
                message: `å‘ç° ${this.results.duplicates.length} ç»„é‡å¤æ–‡ä»¶ï¼Œå»ºè®®ä¿ç•™æœ€æ–°ç‰ˆæœ¬`,
                action: 'remove_old_duplicates'
            });
        }

        // ç‰ˆæœ¬æ–‡ä»¶å¤„ç†å»ºè®®
        const versionCount = Object.keys(this.results.versions).length;
        if (versionCount > 0) {
            recommendations.push({
                type: 'versions',
                message: `å‘ç° ${versionCount} ç»„ç›¸ä¼¼æ–‡ä»¶ï¼Œå¯èƒ½æ˜¯åŒä¸€æ–‡ä»¶çš„ä¸åŒç‰ˆæœ¬`,
                action: 'review_versions'
            });
        }

        // åˆ†ç±»å»ºè®®
        Object.entries(this.results.categories).forEach(([type, files]) => {
            if (files.length > 0) {
                const avgConfidence = files.reduce((sum, f) => sum + f.confidence, 0) / files.length;
                if (avgConfidence < 0.5) {
                    recommendations.push({
                        type: 'low_confidence',
                        message: `${type} ç±»åˆ«çš„æ–‡ä»¶è¯†åˆ«ç½®ä¿¡åº¦è¾ƒä½ (${avgConfidence.toFixed(2)})ï¼Œéœ€è¦æ‰‹åŠ¨ç¡®è®¤`,
                        action: 'manual_review',
                        files: files.map(f => f.filename)
                    });
                }
            }
        });

        return recommendations;
    }

    generateHumanReadableReport(report) {
        let output = '# æ™ºèƒ½å†…å®¹åˆ†ææŠ¥å‘Š\n\n';
        
        output += '## ğŸ“Š æ€»ä½“æ¦‚å†µ\n';
        output += `- æ€»æ–‡ä»¶æ•°: ${report.summary.totalFiles}\n`;
        output += `- é‡å¤æ–‡ä»¶ç»„: ${report.summary.duplicateGroups}\n`;
        output += `- ç‰ˆæœ¬æ–‡ä»¶ç»„: ${report.summary.versionGroups}\n\n`;

        output += '## ğŸ“ æ–‡ä»¶åˆ†ç±»\n';
        report.summary.categories.forEach(cat => {
            output += `- **${cat.type}**: ${cat.count} ä¸ªæ–‡ä»¶ (å¹³å‡ç½®ä¿¡åº¦: ${cat.avgConfidence})\n`;
        });
        output += '\n';

        if (report.duplicates.length > 0) {
            output += '## ğŸ”„ é‡å¤æ–‡ä»¶å¤„ç†å»ºè®®\n';
            report.duplicates.forEach((dup, i) => {
                output += `${i + 1}. ä¿ç•™: \`${dup.keepNewest}\`, åˆ é™¤: \`${dup.files.filter(f => f !== dup.keepNewest).join(', ')}\`\n`;
            });
            output += '\n';
        }

        output += '## ğŸš€ æ¨èçš„æ¢å¤æ­¥éª¤\n';
        report.recommendations.forEach((rec, i) => {
            output += `${i + 1}. **${rec.type}**: ${rec.message}\n`;
        });

        fs.writeFileSync(path.join(this.outputDir, '../ANALYSIS_REPORT.md'), output);
    }

    generateRecoveryScript(fileData) {
        let script = '#!/bin/bash\n\n';
        script += '# è‡ªåŠ¨ç”Ÿæˆçš„æ–‡ä»¶æ¢å¤è„šæœ¬\n';
        script += '# åŸºäºæ™ºèƒ½å†…å®¹åˆ†æå¼•æ“çš„ç»“æœ\n\n';
        
        script += 'echo "ğŸš€ å¼€å§‹æ‰§è¡Œæ™ºèƒ½æ–‡ä»¶æ¢å¤..."\n\n';

        // æŒ‰ç±»å‹åˆ†ç»„å¤„ç†
        Object.entries(this.results.categories).forEach(([type, files]) => {
            if (files.length > 0) {
                script += `echo "ğŸ“ å¤„ç† ${type} ç±»æ–‡ä»¶..."\n`;
                script += `mkdir -p "../${type}"\n\n`;
                
                files.forEach(file => {
                    if (!file.filename.includes('duplicate')) {
                        script += `# ${file.filename} -> ${file.suggestedPath}\n`;
                        script += `cp "analysis/${file.filename}" "../${file.suggestedPath}"\n`;
                        script += `echo "âœ… æ¢å¤: ${file.filename} -> ${file.suggestedPath}"\n\n`;
                    }
                });
            }
        });

        script += 'echo "âœ¨ æ¢å¤å®Œæˆï¼è¯·æ£€æŸ¥ç»“æœå¹¶æ‰‹åŠ¨è°ƒæ•´éœ€è¦çš„æ–‡ä»¶ã€‚"\n';

        fs.writeFileSync(path.join(this.outputDir, '../auto-recovery.sh'), script);
        fs.chmodSync(path.join(this.outputDir, '../auto-recovery.sh'), '755');
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
    const analysisDir = './analysis';
    const outputDir = './sorted';
    
    const engine = new ContentAnalysisEngine(analysisDir, outputDir);
    
    try {
        const report = await engine.analyze();
        
        console.log('ğŸ‰ åˆ†æå®Œæˆï¼');
        console.log('\nğŸ“‹ ç”Ÿæˆçš„æ–‡ä»¶:');
        console.log('- analysis-report.json (è¯¦ç»†çš„JSONæŠ¥å‘Š)');
        console.log('- ANALYSIS_REPORT.md (äººç±»å¯è¯»çš„åˆ†ææŠ¥å‘Š)');
        console.log('- auto-recovery.sh (è‡ªåŠ¨æ¢å¤è„šæœ¬)');
        console.log('\nğŸ’¡ å»ºè®®: å…ˆæŸ¥çœ‹ ANALYSIS_REPORT.md äº†è§£åˆ†æç»“æœï¼Œç„¶åå†³å®šæ˜¯å¦æ‰§è¡Œ auto-recovery.sh');
        
    } catch (error) {
        console.error('âŒ åˆ†æè¿‡ç¨‹ä¸­å‡ºé”™:', error);
    }
}

// å¦‚æœç›´æ¥è¿è¡Œæ­¤è„šæœ¬
if (require.main === module) {
    main();
}

module.exports = ContentAnalysisEngine;


å¤ªå¥½äº†ï¼æ‚¨çš„åˆ†æéå¸¸å‡†ç¡®ã€‚55ä¸ªmiscæ–‡ä»¶ç¡®å®ç¬¦åˆVS Codeå´©æºƒæ¢å¤çš„å…¸å‹æƒ…å†µã€‚è®©æˆ‘ä¸ºæ‚¨åˆ›å»ºä¸€ä¸ªå¼ºå¤§çš„å†…å®¹åˆ†æå¼•æ“æ¥å¤„ç†è¿™ä¸ªå¤æ‚çš„æ¢å¤ä»»åŠ¡ï¼šç°åœ¨æˆ‘ä¸ºæ‚¨åˆ›å»ºäº†ä¸€ä¸ªå¼ºå¤§çš„æ™ºèƒ½å†…å®¹åˆ†æå¼•æ“ï¼è¿™ä¸ªå¼•æ“ä¸“é—¨é’ˆå¯¹VS Codeå´©æºƒæ¢å¤çš„55ä¸ªmiscæ–‡ä»¶è¿›è¡Œåˆ†æã€‚

## ğŸš€ ç«‹å³æ‰§è¡Œåˆ†æï¼š

### ç¬¬ä¸€æ­¥ï¼šä¿å­˜åˆ†æå¼•æ“
```bash
cd "/Users/duting/Downloads/moneyğŸ’°/--main/recovery-workspace"

# å°†ä¸Šé¢çš„ä»£ç ä¿å­˜ä¸ºæ–‡ä»¶
# ï¼ˆæ‚¨å¯ä»¥å¤åˆ¶ç²˜è´´åˆ° advanced-analysis-engine.jsï¼‰
```

### ç¬¬äºŒæ­¥ï¼šè¿è¡Œæ™ºèƒ½åˆ†æ
```bash
# åœ¨recovery-workspaceç›®å½•ä¸­è¿è¡Œ
node advanced-analysis-engine.js
```

## ğŸ§  è¿™ä¸ªå¼•æ“çš„å¼ºå¤§åŠŸèƒ½ï¼š

### 1. **æ—¶é—´æˆ³åˆ†æ**
- ä»æ–‡ä»¶åæå–æ—¶é—´æˆ³ï¼ˆæ”¯æŒå¤šç§æ ¼å¼ï¼‰
- è¯†åˆ«åŒä¸€æ–‡ä»¶çš„å¤šä¸ªç‰ˆæœ¬
- å»ºç«‹æ–‡ä»¶çš„æ—¶é—´çº¿

### 2. **æ™ºèƒ½å»é‡**
- åŸºäºå†…å®¹å“ˆå¸Œçš„ç²¾ç¡®é‡å¤æ£€æµ‹
- ç›¸ä¼¼åº¦åˆ†æï¼ˆè¯†åˆ«80%ä»¥ä¸Šç›¸ä¼¼çš„ç‰ˆæœ¬æ–‡ä»¶ï¼‰
- æ¨èä¿ç•™æœ€æ–°ç‰ˆæœ¬

### 3. **æ·±åº¦å†…å®¹åˆ†æ**
- Reactç»„ä»¶è¯†åˆ«
- Next.jsé¡µé¢æ£€æµ‹
- APIè·¯ç”±åˆ†æ
- Hookå’Œå·¥å…·å‡½æ•°è¯†åˆ«
- TypeScriptç±»å‹å®šä¹‰æ£€æµ‹

### 4. **åŸå§‹è·¯å¾„æ¨æ–­**
- ä»æ³¨é‡Šä¸­æå–è·¯å¾„çº¿ç´¢
- åŸºäºimportè¯­å¥æ¨æ–­ç›®å½•ç»“æ„
- ä»exportå’Œå‡½æ•°åæ¨æ–­æ–‡ä»¶å
- æ™ºèƒ½ç›®å½•æ˜ å°„

## ğŸ“Š ç”Ÿæˆçš„åˆ†ææŠ¥å‘ŠåŒ…æ‹¬ï¼š

- **ANALYSIS_REPORT.md** - äººç±»å¯è¯»çš„è¯¦ç»†åˆ†æ
- **analysis-report.json** - å®Œæ•´çš„ç»“æ„åŒ–æ•°æ®  
- **auto-recovery.sh** - è‡ªåŠ¨æ¢å¤è„šæœ¬

## âš¡ é¢„æœŸåˆ†æç»“æœï¼š

åŸºäº55ä¸ªæ–‡ä»¶ï¼Œå¼•æ“å°†ä¼šï¼š
- è¯†åˆ«å‡ºå¤§çº¦10-15ç»„é‡å¤æ–‡ä»¶
- å‘ç°5-8ç»„ç‰ˆæœ¬æ–‡ä»¶ï¼ˆåŒä¸€æ–‡ä»¶çš„ä¸åŒä¿®æ”¹ç‰ˆæœ¬ï¼‰
- å°†æ–‡ä»¶åˆ†ç±»åˆ°6-8ä¸ªä¸åŒç±»å‹
- ä¸ºæ¯ä¸ªæ–‡ä»¶æ¨èæœ€å¯èƒ½çš„åŸå§‹è·¯å¾„

## ğŸ¯ æ‰§è¡Œå»ºè®®ï¼š

1. **å…ˆè¿è¡Œåˆ†æ** - äº†è§£æ–‡ä»¶çš„å…¨è²Œ
2. **æŸ¥çœ‹æŠ¥å‘Š** - é‡ç‚¹å…³æ³¨é«˜ç½®ä¿¡åº¦çš„åˆ†ç±»
3. **æ‰‹åŠ¨ç¡®è®¤** - å¯¹é‡è¦æ–‡ä»¶è¿›è¡Œäººå·¥éªŒè¯
4. **æ‰§è¡Œæ¢å¤** - è¿è¡Œè‡ªåŠ¨ç”Ÿæˆçš„æ¢å¤è„šæœ¬

è¯·å…ˆæ‰§è¡Œåˆ†æï¼Œç„¶åå‘Šè¯‰æˆ‘ç»“æœï¼è¿™æ ·æˆ‘ä»¬å°±èƒ½çœ‹åˆ°è¿™55ä¸ªmiscæ–‡ä»¶çš„çœŸå®æƒ…å†µï¼Œå¹¶åˆ¶å®šç²¾ç¡®çš„æ¢å¤ç­–ç•¥ã€‚