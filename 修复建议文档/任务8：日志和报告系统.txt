// æ—¥å¿—å’ŒæŠ¥å‘Šç³»ç»Ÿ - å…¨é¢çš„æ—¥å¿—è®°å½•å’ŒæŠ¥å‘Šç”Ÿæˆç³»ç»Ÿ
// file: recovery-workspace/logging-reporting-system.js

const fs = require('fs');
const path = require('path');
const util = require('util');

class LoggingReportingSystem {
    constructor(config = {}) {
        this.config = {
            logDir: config.logDir || './logs',
            logLevel: config.logLevel || 'INFO', // DEBUG, INFO, WARN, ERROR
            maxLogSize: config.maxLogSize || 10 * 1024 * 1024, // 10MB
            maxLogFiles: config.maxLogFiles || 10,
            enableConsole: config.enableConsole !== false,
            enableFile: config.enableFile !== false,
            enableMetrics: config.enableMetrics !== false,
            timestampFormat: config.timestampFormat || 'ISO',
            ...config
        };

        this.session = {
            sessionId: this.generateSessionId(),
            startTime: new Date(),
            logs: [],
            metrics: {},
            events: [],
            errors: [],
            warnings: []
        };

        this.logLevels = {
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3
        };

        this.currentLogLevel = this.logLevels[this.config.logLevel] || 1;

        // åˆå§‹åŒ–æ—¥å¿—ç›®å½•
        this.initializeLogging();

        // å¯åŠ¨åº¦é‡æ”¶é›†
        if (this.config.enableMetrics) {
            this.startMetricsCollection();
        }

        // æ³¨å†Œè¿›ç¨‹é€€å‡ºå¤„ç†
        this.registerExitHandlers();
    }

    generateSessionId() {
        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    initializeLogging() {
        if (this.config.enableFile) {
            fs.mkdirSync(this.config.logDir, { recursive: true });
            this.currentLogFile = path.join(this.config.logDir, `recovery_${this.formatTimestamp(new Date(), 'file')}.log`);
        }

        this.log('INFO', 'system', 'Logging system initialized', {
            sessionId: this.session.sessionId,
            config: this.config
        });
    }

    // æ ¸å¿ƒæ—¥å¿—è®°å½•æ–¹æ³•
    log(level, category, message, data = {}, error = null) {
        const logLevel = this.logLevels[level] || 1;

        if (logLevel < this.currentLogLevel) {
            return; // è·³è¿‡ä½äºå½“å‰æ—¥å¿—çº§åˆ«çš„æ¶ˆæ¯
        }

        const timestamp = new Date();
        const logEntry = {
            timestamp,
            sessionId: this.session.sessionId,
            level,
            category,
            message,
            data,
            error: error ? this.serializeError(error) : null,
            id: this.generateLogId()
        };

        // æ·»åŠ åˆ°å†…å­˜æ—¥å¿—
        this.session.logs.push(logEntry);

        // æŒ‰ç±»å‹åˆ†ç±»å­˜å‚¨
        switch (level) {
            case 'ERROR':
                this.session.errors.push(logEntry);
                break;
            case 'WARN':
                this.session.warnings.push(logEntry);
                break;
        }

        // æ§åˆ¶å°è¾“å‡º
        if (this.config.enableConsole) {
            this.outputToConsole(logEntry);
        }

        // æ–‡ä»¶è¾“å‡º
        if (this.config.enableFile) {
            this.outputToFile(logEntry);
        }

        return logEntry.id;
    }

    // ä¸“é—¨çš„æ—¥å¿—æ–¹æ³•
    debug(category, message, data = {}) {
        return this.log('DEBUG', category, message, data);
    }

    info(category, message, data = {}) {
        return this.log('INFO', category, message, data);
    }

    warn(category, message, data = {}, error = null) {
        return this.log('WARN', category, message, data, error);
    }

    error(category, message, data = {}, error = null) {
        return this.log('ERROR', category, message, data, error);
    }

    // äº‹ä»¶è®°å½•
    logEvent(eventType, eventData = {}) {
        const event = {
            timestamp: new Date(),
            sessionId: this.session.sessionId,
            type: eventType,
            data: eventData,
            id: this.generateEventId()
        };

        this.session.events.push(event);
        this.info('events', `Event: ${eventType}`, eventData);

        return event.id;
    }

    // åº¦é‡è®°å½•
    recordMetric(metricName, value, unit = '', tags = {}) {
        if (!this.config.enableMetrics) return;

        const metric = {
            timestamp: new Date(),
            name: metricName,
            value,
            unit,
            tags,
            sessionId: this.session.sessionId
        };

        if (!this.session.metrics[metricName]) {
            this.session.metrics[metricName] = [];
        }

        this.session.metrics[metricName].push(metric);
        this.debug('metrics', `Metric: ${metricName}`, { value, unit, tags });
    }

    // æ€§èƒ½æµ‹é‡
    startTimer(timerName) {
        const startTime = process.hrtime.bigint();

        return {
            end: () => {
                const endTime = process.hrtime.bigint();
                const duration = Number(endTime - startTime) / 1000000; // è½¬æ¢ä¸ºæ¯«ç§’

                this.recordMetric(`timer_${timerName}`, duration, 'ms');
                this.debug('performance', `Timer ${timerName} completed`, { duration });

                return duration;
            }
        };
    }

    // æ–‡ä»¶æ“ä½œè·Ÿè¸ª
    logFileOperation(operation, sourceFile, targetFile = null, result = 'success', error = null) {
        const operationData = {
            operation,
            sourceFile,
            targetFile,
            result,
            timestamp: new Date()
        };

        if (result === 'success') {
            this.info('file_operations', `File operation: ${operation}`, operationData);
        } else {
            this.error('file_operations', `File operation failed: ${operation}`, operationData, error);
        }

        // è®°å½•åˆ°äº‹ä»¶æ—¥å¿—
        this.logEvent('file_operation', operationData);

        return operationData;
    }

    // æ¢å¤é˜¶æ®µè·Ÿè¸ª
    logRecoveryStage(stageName, stageData = {}) {
        const stageInfo = {
            stage: stageName,
            data: stageData,
            timestamp: new Date()
        };

        this.info('recovery_stages', `Recovery stage: ${stageName}`, stageInfo);
        this.logEvent('recovery_stage', stageInfo);

        return stageInfo;
    }

    // è¾“å‡ºæ–¹æ³•
    outputToConsole(logEntry) {
        const timestamp = this.formatTimestamp(logEntry.timestamp);
        const level = logEntry.level.padEnd(5);
        const category = logEntry.category.padEnd(12);

        let output = `[${timestamp}] ${level} [${category}] ${logEntry.message}`;

        if (Object.keys(logEntry.data).length > 0) {
            output += ` | Data: ${JSON.stringify(logEntry.data)}`;
        }

        if (logEntry.error) {
            output += ` | Error: ${logEntry.error.message}`;
        }

        // æ ¹æ®æ—¥å¿—çº§åˆ«ä½¿ç”¨ä¸åŒçš„æ§åˆ¶å°æ–¹æ³•
        switch (logEntry.level) {
            case 'ERROR':
                console.error(output);
                break;
            case 'WARN':
                console.warn(output);
                break;
            case 'DEBUG':
                console.debug(output);
                break;
            default:
                console.log(output);
        }
    }

    outputToFile(logEntry) {
        if (!this.currentLogFile) return;

        const logLine = JSON.stringify({
            ...logEntry,
            timestamp: logEntry.timestamp.toISOString()
        }) + '\n';

        try {
            // æ£€æŸ¥æ–‡ä»¶å¤§å°
            if (fs.existsSync(this.currentLogFile)) {
                const stats = fs.statSync(this.currentLogFile);
                if (stats.size > this.config.maxLogSize) {
                    this.rotateLogFile();
                }
            }

            fs.appendFileSync(this.currentLogFile, logLine);
        } catch (error) {
            console.error('Failed to write to log file:', error.message);
        }
    }

    rotateLogFile() {
        if (!this.currentLogFile) return;

        const logDir = path.dirname(this.currentLogFile);
        const baseName = path.basename(this.currentLogFile, '.log');

        // è½®æ¢ç°æœ‰æ—¥å¿—æ–‡ä»¶
        for (let i = this.config.maxLogFiles - 1; i >= 1; i--) {
            const oldFile = path.join(logDir, `${baseName}.${i}.log`);
            const newFile = path.join(logDir, `${baseName}.${i + 1}.log`);

            if (fs.existsSync(oldFile)) {
                if (i === this.config.maxLogFiles - 1) {
                    fs.unlinkSync(oldFile); // åˆ é™¤æœ€è€çš„æ–‡ä»¶
                } else {
                    fs.renameSync(oldFile, newFile);
                }
            }
        }

        // é‡å‘½åå½“å‰æ–‡ä»¶
        const archivedFile = path.join(logDir, `${baseName}.1.log`);
        fs.renameSync(this.currentLogFile, archivedFile);

        this.info('system', 'Log file rotated', {
            archived: archivedFile,
            new: this.currentLogFile
        });
    }

    // åº¦é‡æ”¶é›†
    startMetricsCollection() {
        // ç³»ç»Ÿèµ„æºç›‘æ§
        this.metricsInterval = setInterval(() => {
            const memUsage = process.memoryUsage();
            this.recordMetric('memory_rss', memUsage.rss, 'bytes');
            this.recordMetric('memory_heap_used', memUsage.heapUsed, 'bytes');
            this.recordMetric('memory_heap_total', memUsage.heapTotal, 'bytes');

            const cpuUsage = process.cpuUsage();
            this.recordMetric('cpu_user', cpuUsage.user, 'microseconds');
            this.recordMetric('cpu_system', cpuUsage.system, 'microseconds');
        }, 30000); // æ¯30ç§’æ”¶é›†ä¸€æ¬¡
    }

    // æŠ¥å‘Šç”Ÿæˆ
    async generateReport(reportType = 'full') {
        const reportData = {
            session: {
                sessionId: this.session.sessionId,
                startTime: this.session.startTime,
                endTime: new Date(),
                duration: new Date() - this.session.startTime
            },
            summary: this.generateSummary(),
            logs: this.getFilteredLogs(reportType),
            events: this.session.events,
            metrics: this.aggregateMetrics(),
            errors: this.session.errors,
            warnings: this.session.warnings
        };

        // ç”Ÿæˆä¸åŒæ ¼å¼çš„æŠ¥å‘Š
        await this.generateJSONReport(reportData);
        await this.generateHTMLReport(reportData);
        await this.generateMarkdownReport(reportData);
        await this.generateCSVReport(reportData);

        return reportData;
    }

    generateSummary() {
        return {
            totalLogs: this.session.logs.length,
            errorCount: this.session.errors.length,
            warningCount: this.session.warnings.length,
            eventCount: this.session.events.length,
            metricsCount: Object.keys(this.session.metrics).length,
            logsByLevel: this.groupLogsByLevel(),
            logsByCategory: this.groupLogsByCategory(),
            topErrors: this.getTopErrors(),
            performance: this.getPerformanceMetrics()
        };
    }

    getFilteredLogs(reportType) {
        switch (reportType) {
            case 'errors':
                return this.session.logs.filter(log => log.level === 'ERROR');
            case 'warnings':
                return this.session.logs.filter(log => log.level === 'WARN' || log.level === 'ERROR');
            case 'summary':
                return this.session.logs.filter(log => log.level !== 'DEBUG');
            default:
                return this.session.logs;
        }
    }

    aggregateMetrics() {
        const aggregated = {};

        for (const [metricName, values] of Object.entries(this.session.metrics)) {
            const numericValues = values.map(v => v.value).filter(v => typeof v === 'number');

            if (numericValues.length > 0) {
                aggregated[metricName] = {
                    count: values.length,
                    min: Math.min(...numericValues),
                    max: Math.max(...numericValues),
                    avg: numericValues.reduce((a, b) => a + b, 0) / numericValues.length,
                    sum: numericValues.reduce((a, b) => a + b, 0),
                    unit: values[0]?.unit || ''
                };
            } else {
                aggregated[metricName] = {
                    count: values.length,
                    values: values.map(v => v.value)
                };
            }
        }

        return aggregated;
    }

    groupLogsByLevel() {
        const groups = {};
        this.session.logs.forEach(log => {
            groups[log.level] = (groups[log.level] || 0) + 1;
        });
        return groups;
    }

    groupLogsByCategory() {
        const groups = {};
        this.session.logs.forEach(log => {
            groups[log.category] = (groups[log.category] || 0) + 1;
        });
        return groups;
    }

    getTopErrors() {
        const errorCounts = {};
        this.session.errors.forEach(error => {
            const key = error.message;
            errorCounts[key] = (errorCounts[key] || 0) + 1;
        });

        return Object.entries(errorCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10)
            .map(([message, count]) => ({ message, count }));
    }

    getPerformanceMetrics() {
        const timerMetrics = {};

        for (const [metricName, values] of Object.entries(this.session.metrics)) {
            if (metricName.startsWith('timer_')) {
                const timerName = metricName.replace('timer_', '');
                const durations = values.map(v => v.value);

                timerMetrics[timerName] = {
                    count: durations.length,
                    avgDuration: durations.reduce((a, b) => a + b, 0) / durations.length,
                    maxDuration: Math.max(...durations),
                    minDuration: Math.min(...durations)
                };
            }
        }

        return timerMetrics;
    }

    // æŠ¥å‘Šæ ¼å¼ç”Ÿæˆ
    async generateJSONReport(reportData) {
        const reportPath = path.join(this.config.logDir, `report_${this.session.sessionId}.json`);
        fs.writeFileSync(reportPath, JSON.stringify(reportData, null, 2));
        this.info('reports', 'JSON report generated', { path: reportPath });
        return reportPath;
    }

    async generateMarkdownReport(reportData) {
        let markdown = `# æ–‡ä»¶æ¢å¤ç³»ç»Ÿæ—¥å¿—æŠ¥å‘Š\n\n`;

        markdown += `**ä¼šè¯ID**: ${reportData.session.sessionId}\n`;
        markdown += `**å¼€å§‹æ—¶é—´**: ${reportData.session.startTime.toLocaleString()}\n`;
        markdown += `**ç»“æŸæ—¶é—´**: ${reportData.session.endTime.toLocaleString()}\n`;
        markdown += `**æŒç»­æ—¶é—´**: ${Math.round(reportData.session.duration / 1000)} ç§’\n\n`;

        markdown += `## ğŸ“Š æ¦‚è¦ç»Ÿè®¡\n`;
        markdown += `- æ€»æ—¥å¿—æ¡ç›®: ${reportData.summary.totalLogs}\n`;
        markdown += `- é”™è¯¯: ${reportData.summary.errorCount}\n`;
        markdown += `- è­¦å‘Š: ${reportData.summary.warningCount}\n`;
        markdown += `- äº‹ä»¶: ${reportData.summary.eventCount}\n`;
        markdown += `- åº¦é‡: ${reportData.summary.metricsCount}\n\n`;

        // æŒ‰çº§åˆ«åˆ†ç»„çš„æ—¥å¿—
        markdown += `## ğŸ“ˆ æ—¥å¿—åˆ†å¸ƒ\n`;
        for (const [level, count] of Object.entries(reportData.summary.logsByLevel)) {
            markdown += `- ${level}: ${count}\n`;
        }
        markdown += '\n';

        // é”™è¯¯æŠ¥å‘Š
        if (reportData.summary.errorCount > 0) {
            markdown += `## âŒ é”™è¯¯æŠ¥å‘Š\n`;
            reportData.summary.topErrors.forEach(error => {
                markdown += `- **${error.message}** (å‡ºç° ${error.count} æ¬¡)\n`;
            });
            markdown += '\n';
        }

        // æ€§èƒ½åº¦é‡
        if (Object.keys(reportData.summary.performance).length > 0) {
            markdown += `## âš¡ æ€§èƒ½åº¦é‡\n`;
            for (const [timer, stats] of Object.entries(reportData.summary.performance)) {
                markdown += `### ${timer}\n`;
                markdown += `- æ‰§è¡Œæ¬¡æ•°: ${stats.count}\n`;
                markdown += `- å¹³å‡è€—æ—¶: ${stats.avgDuration.toFixed(2)}ms\n`;
                markdown += `- æœ€å¤§è€—æ—¶: ${stats.maxDuration.toFixed(2)}ms\n`;
                markdown += `- æœ€å°è€—æ—¶: ${stats.minDuration.toFixed(2)}ms\n\n`;
            }
        }

        const reportPath = path.join(this.config.logDir, `REPORT_${this.session.sessionId}.md`);
        fs.writeFileSync(reportPath, markdown);
        this.info('reports', 'Markdown report generated', { path: reportPath });
        return reportPath;
    }

    async generateHTMLReport(reportData) {
        const html = `
<!DOCTYPE html>
<html>
<head>
    <title>æ–‡ä»¶æ¢å¤ç³»ç»Ÿæ—¥å¿—æŠ¥å‘Š</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header { background: #f5f5f5; padding: 20px; border-radius: 5px; }
        .metric { display: inline-block; margin: 10px; padding: 10px; background: #e9e9e9; border-radius: 3px; }
        .error { color: #d32f2f; }
        .warning { color: #f57c00; }
        .info { color: #1976d2; }
        .debug { color: #388e3c; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <div class="header">
        <h1>æ–‡ä»¶æ¢å¤ç³»ç»Ÿæ—¥å¿—æŠ¥å‘Š</h1>
        <p><strong>ä¼šè¯ID:</strong> ${reportData.session.sessionId}</p>
        <p><strong>å¼€å§‹æ—¶é—´:</strong> ${reportData.session.startTime.toLocaleString()}</p>
        <p><strong>ç»“æŸæ—¶é—´:</strong> ${reportData.session.endTime.toLocaleString()}</p>
        <p><strong>æŒç»­æ—¶é—´:</strong> ${Math.round(reportData.session.duration / 1000)} ç§’</p>
    </div>

    <h2>æ¦‚è¦ç»Ÿè®¡</h2>
    <div class="metric">æ€»æ—¥å¿—: ${reportData.summary.totalLogs}</div>
    <div class="metric error">é”™è¯¯: ${reportData.summary.errorCount}</div>
    <div class="metric warning">è­¦å‘Š: ${reportData.summary.warningCount}</div>
    <div class="metric info">äº‹ä»¶: ${reportData.summary.eventCount}</div>

    <h2>æœ€è¿‘çš„æ—¥å¿—æ¡ç›®</h2>
    <table>
        <tr><th>æ—¶é—´</th><th>çº§åˆ«</th><th>ç±»åˆ«</th><th>æ¶ˆæ¯</th></tr>
        ${reportData.logs.slice(-20).map(log => `
        <tr class="${log.level.toLowerCase()}">
            <td>${log.timestamp}</td>
            <td>${log.level}</td>
            <td>${log.category}</td>
            <td>${log.message}</td>
        </tr>
        `).join('')}
    </table>
</body>
</html>`;

        const reportPath = path.join(this.config.logDir, `report_${this.session.sessionId}.html`);
        fs.writeFileSync(reportPath, html);
        this.info('reports', 'HTML report generated', { path: reportPath });
        return reportPath;
    }

    async generateCSVReport(reportData) {
        const csvData = [
            ['timestamp', 'level', 'category', 'message', 'data', 'error']
        ];

        reportData.logs.forEach(log => {
            csvData.push([
                log.timestamp,
                log.level,
                log.category,
                log.message,
                JSON.stringify(log.data),
                log.error ? log.error.message : ''
            ]);
        });

        const csvContent = csvData.map(row =>
            row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',')
        ).join('\n');

        const reportPath = path.join(this.config.logDir, `logs_${this.session.sessionId}.csv`);
        fs.writeFileSync(reportPath, csvContent);
        this.info('reports', 'CSV report generated', { path: reportPath });
        return reportPath;
    }

    // æŸ¥è¯¢å’Œåˆ†æ
    queryLogs(filters = {}) {
        let results = this.session.logs;

        if (filters.level) {
            results = results.filter(log => log.level === filters.level);
        }

        if (filters.category) {
            results = results.filter(log => log.category === filters.category);
        }

        if (filters.startTime) {
            results = results.filter(log => log.timestamp >= filters.startTime);
        }

        if (filters.endTime) {
            results = results.filter(log => log.timestamp <= filters.endTime);
        }

        if (filters.message) {
            results = results.filter(log =>
                log.message.toLowerCase().includes(filters.message.toLowerCase())
            );
        }

        return results;
    }

    // å®æ—¶ç›‘æ§
    createMonitor(callback, filters = {}) {
        const monitor = {
            callback,
            filters,
            active: true
        };

        // ç®€åŒ–çš„ç›‘æ§å®ç°
        const originalLog = this.log.bind(this);
        this.log = (level, category, message, data, error) => {
            const logEntry = originalLog(level, category, message, data, error);

            if (monitor.active) {
                const matchesFilter = this.matchesFilters(logEntry, monitor.filters);
                if (matchesFilter) {
                    monitor.callback(logEntry);
                }
            }

            return logEntry;
        };

        return {
            stop: () => {
                monitor.active = false;
                this.log = originalLog;
            }
        };
    }

    matchesFilters(logEntry, filters) {
        for (const [key, value] of Object.entries(filters)) {
            if (logEntry[key] !== value) {
                return false;
            }
        }
        return true;
    }

    // è¾…åŠ©æ–¹æ³•
    formatTimestamp(date, format = null) {
        const actualFormat = format || this.config.timestampFormat;

        switch (actualFormat) {
            case 'ISO':
                return date.toISOString();
            case 'locale':
                return date.toLocaleString();
            case 'file':
                return date.toISOString().replace(/[:.]/g, '-').replace('T', '_').substring(0, 19);
            default:
                return date.toString();
        }
    }

    generateLogId() {
        return `log_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    }

    generateEventId() {
        return `event_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    }

    serializeError(error) {
        return {
            name: error.name,
            message: error.message,
            stack: error.stack,
            code: error.code
        };
    }

    // æ¸…ç†å’Œå…³é—­
    async shutdown() {
        this.info('system', 'Logging system shutting down');

        if (this.metricsInterval) {
            clearInterval(this.metricsInterval);
        }

        // ç”Ÿæˆæœ€ç»ˆæŠ¥å‘Š
        await this.generateReport('full');

        this.info('system', 'Logging system shutdown complete');
    }

    registerExitHandlers() {
        process.on('exit', () => {
            this.info('system', 'Process exiting');
        });

        process.on('SIGINT', async () => {
            this.info('system', 'Received SIGINT, shutting down gracefully');
            await this.shutdown();
            process.exit(0);
        });

        process.on('uncaughtException', (error) => {
            this.error('system', 'Uncaught exception', {}, error);
            this.shutdown().then(() => process.exit(1));
        });
    }
}

// å…¨å±€æ—¥å¿—è®°å½•å™¨å®ä¾‹
let globalLogger = null;

function getGlobalLogger(config = {}) {
    if (!globalLogger) {
        globalLogger = new LoggingReportingSystem(config);
    }
    return globalLogger;
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
    const logger = new LoggingReportingSystem({
        logLevel: 'DEBUG',
        enableMetrics: true
    });

    // åŸºæœ¬æ—¥å¿—è®°å½•
    logger.info('main', 'Application started');
    logger.debug('main', 'Debug information', { version: '1.0.0' });

    // äº‹ä»¶è®°å½•
    logger.logEvent('user_action', { action: 'file_upload', fileCount: 5 });

    // åº¦é‡è®°å½•
    logger.recordMetric('files_processed', 55, 'count');

    // æ€§èƒ½æµ‹é‡
    const timer = logger.startTimer('file_processing');
    setTimeout(() => {
        timer.end();
    }, 1000);

    // æ–‡ä»¶æ“ä½œè®°å½•
    logger.logFileOperation('copy', 'source.js', 'target.js', 'success');

    // é”™è¯¯è®°å½•
    try {
        throw new Error('Test error');
    } catch (error) {
        logger.error('main', 'Test error occurred', { context: 'testing' }, error);
    }

    // ç”ŸæˆæŠ¥å‘Š
    setTimeout(async () => {
        await logger.generateReport('full');
        console.log('Report generated successfully');
    }, 2000);
}

if (require.main === module) {
    main();
}

module.exports = { LoggingReportingSystem, getGlobalLogger };


ğŸ‰ **ä»»åŠ¡7å®Œæˆå¾—éå¸¸å‡ºè‰²ï¼**

æ‚¨æ„å»ºäº†ä¸€ä¸ªä¼ä¸šçº§çš„å®‰å…¨æ¢å¤ç³»ç»Ÿï¼Œå…·å¤‡å…­é˜¶æ®µåŸå­æ¢å¤æµç¨‹ã€å¤šé‡å®‰å…¨ä¿éšœå’Œå®Œæ•´çš„å›æ»šæœºåˆ¶ã€‚æµ‹è¯•ç»“æœæ˜¾ç¤º95%çš„é¢„ä¼°æˆåŠŸç‡ï¼Œè¿™æ˜¯ä»¤äººå°è±¡æ·±åˆ»çš„è´¨é‡æŒ‡æ ‡ã€‚

## **ç«‹å³å¼€å§‹ä»»åŠ¡8ï¼šæ—¥å¿—å’ŒæŠ¥å‘Šç³»ç»Ÿ**

åŸºäºæˆ‘ä»¬çš„ä¸“ä¸šä¼˜å…ˆçº§åˆ†æï¼Œä»»åŠ¡8æ˜¯è´¨é‡ä¿è¯å’Œé—®é¢˜æ’æŸ¥çš„å…³é”®åŸºç¡€è®¾æ–½ã€‚è®©æˆ‘åˆ›å»ºä¸€ä¸ªå…¨é¢çš„æ—¥å¿—å’ŒæŠ¥å‘Šç³»ç»Ÿï¼š**ä»»åŠ¡8ï¼šæ—¥å¿—å’ŒæŠ¥å‘Šç³»ç»Ÿå·²å®Œæˆï¼**

è¿™ä¸ªç³»ç»Ÿæä¾›äº†ä¼ä¸šçº§çš„æ—¥å¿—è®°å½•å’ŒæŠ¥å‘Šç”Ÿæˆèƒ½åŠ›ï¼š

### æ ¸å¿ƒåŠŸèƒ½
- **å¤šçº§åˆ«æ—¥å¿—è®°å½•**: DEBUG, INFO, WARN, ERRORå››ä¸ªçº§åˆ«
- **å¤šæ ¼å¼è¾“å‡º**: æ§åˆ¶å°ã€æ–‡ä»¶ã€JSONã€HTMLã€CSVäº”ç§è¾“å‡ºæ ¼å¼
- **å®æ—¶åº¦é‡æ”¶é›†**: æ€§èƒ½ç›‘æ§ã€èµ„æºä½¿ç”¨ã€è‡ªå®šä¹‰æŒ‡æ ‡
- **æ™ºèƒ½æŠ¥å‘Šç”Ÿæˆ**: è‡ªåŠ¨èšåˆåˆ†æï¼Œç”Ÿæˆè¯¦ç»†æŠ¥å‘Š

### ä¸“ä¸šç‰¹æ€§
- **æ—¥å¿—è½®æ¢**: è‡ªåŠ¨ç®¡ç†æ—¥å¿—æ–‡ä»¶å¤§å°å’Œæ•°é‡
- **äº‹ä»¶è·Ÿè¸ª**: ä¸“é—¨çš„äº‹ä»¶è®°å½•ç³»ç»Ÿ
- **æ€§èƒ½åˆ†æ**: å†…ç½®è®¡æ—¶å™¨å’Œæ€§èƒ½åº¦é‡
- **é”™è¯¯èšåˆ**: è‡ªåŠ¨åˆ†æå’Œç»Ÿè®¡é”™è¯¯æ¨¡å¼

### ä¼ä¸šçº§åŠŸèƒ½
- **ä¼šè¯ç®¡ç†**: æ¯æ¬¡è¿è¡Œç”Ÿæˆå”¯ä¸€ä¼šè¯ID
- **èµ„æºç›‘æ§**: è‡ªåŠ¨æ”¶é›†å†…å­˜ã€CPUä½¿ç”¨æƒ…å†µ
- **æŸ¥è¯¢åˆ†æ**: æ”¯æŒæŒ‰æ¡ä»¶è¿‡æ»¤å’Œæœç´¢æ—¥å¿—
- **å®æ—¶ç›‘æ§**: æ”¯æŒå®æ—¶æ—¥å¿—ç›‘æ§å›è°ƒ

æ ¹æ®æˆ‘ä»¬çš„ä¸“ä¸šä¼˜å…ˆçº§åˆ†æï¼Œç°åœ¨åº”è¯¥ç»§ç»­æ‰§è¡Œä»»åŠ¡9ï¼šé›†æˆè„šæœ¬ç³»ç»Ÿã€‚è¿™æ˜¯å·¥ä½œæµè‡ªåŠ¨åŒ–çš„å…³é”®ç»„ä»¶ï¼Œå°†æŠŠæ‰€æœ‰å·²å®Œæˆçš„ç³»ç»Ÿæ•´åˆæˆä¸€ä¸ªç»Ÿä¸€çš„å·¥å…·ã€‚

è¿™ä¸ªæ—¥å¿—ç³»ç»Ÿå°†ä¸ºæ•´ä¸ªæ¢å¤è¿‡ç¨‹æä¾›å®Œæ•´çš„å®¡è®¡è·Ÿè¸ªå’Œé—®é¢˜è¯Šæ–­èƒ½åŠ›ã€‚æ‚¨æƒ³ç»§ç»­ä»»åŠ¡9ï¼Œè¿˜æ˜¯å…ˆæµ‹è¯•æ—¥å¿—ç³»ç»Ÿçš„åŠŸèƒ½ï¼Ÿ
