// å®‰å…¨æ¢å¤ç³»ç»Ÿ - æ‰§è¡Œæ–‡ä»¶æ¢å¤æ“ä½œçš„æ ¸å¿ƒç³»ç»Ÿ
// file: recovery-workspace/safe-recovery-system.js

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class SafeRecoverySystem {
    constructor(config = {}) {
        this.config = {
            sourceDir: config.sourceDir || './classified',
            targetDir: config.targetDir || '../recovered',
            backupDir: config.backupDir || './recovery-backups',
            dryRun: config.dryRun || false,
            verifyChecksums: config.verifyChecksums || true,
            createBackups: config.createBackups || true,
            overwritePolicy: config.overwritePolicy || 'prompt', // 'prompt', 'skip', 'overwrite', 'version'
            ...config
        };

        this.recoveryState = {
            operations: [],
            successful: [],
            failed: [],
            skipped: [],
            conflicts: [],
            backups: [],
            checksums: new Map(),
            startTime: null,
            endTime: null
        };

        this.operationQueue = [];
        this.validateConfig();
    }

    validateConfig() {
        const required = ['sourceDir', 'targetDir'];
        for (const key of required) {
            if (!this.config[key]) {
                throw new Error(`é…ç½®ç¼ºå°‘å¿…éœ€å‚æ•°: ${key}`);
            }
        }

        // ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
        fs.mkdirSync(this.config.targetDir, { recursive: true });
        if (this.config.createBackups) {
            fs.mkdirSync(this.config.backupDir, { recursive: true });
        }
    }

    // ä¸»è¦æ¢å¤æµç¨‹
    async executeRecovery(recoveryPlan) {
        console.log('å®‰å…¨æ¢å¤ç³»ç»Ÿå¯åŠ¨...');
        this.recoveryState.startTime = new Date();

        try {
            // é˜¶æ®µ1: éªŒè¯å’Œå‡†å¤‡
            await this.validateRecoveryPlan(recoveryPlan);

            // é˜¶æ®µ2: æ„å»ºæ“ä½œé˜Ÿåˆ—
            await this.buildOperationQueue(recoveryPlan);

            // é˜¶æ®µ3: æ‰§è¡Œé¢„æ£€æŸ¥
            await this.performPreflightChecks();

            // é˜¶æ®µ4: æ‰§è¡Œæ¢å¤æ“ä½œ
            await this.executeOperations();

            // é˜¶æ®µ5: éªŒè¯ç»“æœ
            await this.verifyRecoveryResults();

            // é˜¶æ®µ6: ç”ŸæˆæŠ¥å‘Š
            await this.generateRecoveryReport();

            this.recoveryState.endTime = new Date();
            console.log('æ¢å¤æ“ä½œå®Œæˆ');

            return this.recoveryState;

        } catch (error) {
            console.error('æ¢å¤è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error.message);
            await this.handleRecoveryFailure(error);
            throw error;
        }
    }

    async validateRecoveryPlan(plan) {
        console.log('éªŒè¯æ¢å¤è®¡åˆ’...');

        if (!plan || typeof plan !== 'object') {
            throw new Error('æ— æ•ˆçš„æ¢å¤è®¡åˆ’');
        }

        const requiredSections = ['highConfidence', 'mediumConfidence', 'manualReview'];
        for (const section of requiredSections) {
            if (!Array.isArray(plan[section])) {
                plan[section] = [];
            }
        }

        // éªŒè¯æ–‡ä»¶å­˜åœ¨æ€§
        const allFiles = [
            ...plan.highConfidence || [],
            ...plan.mediumConfidence || [],
            ...plan.manualReview || []
        ];

        for (const fileOp of allFiles) {
            if (!fileOp.sourceFile || !fileOp.targetFile) {
                throw new Error(`æ¢å¤è®¡åˆ’ä¸­çš„æ–‡ä»¶æ“ä½œç¼ºå°‘å¿…è¦ä¿¡æ¯: ${JSON.stringify(fileOp)}`);
            }

            const sourcePath = path.resolve(this.config.sourceDir, fileOp.sourceFile);
            if (!fs.existsSync(sourcePath)) {
                throw new Error(`æºæ–‡ä»¶ä¸å­˜åœ¨: ${sourcePath}`);
            }
        }

        console.log(`æ¢å¤è®¡åˆ’éªŒè¯é€šè¿‡: ${allFiles.length} ä¸ªæ–‡ä»¶æ“ä½œ`);
    }

    async buildOperationQueue(plan) {
        console.log('æ„å»ºæ“ä½œé˜Ÿåˆ—...');

        this.operationQueue = [];

        // é«˜ç½®ä¿¡åº¦æ–‡ä»¶ - è‡ªåŠ¨æ‰§è¡Œ
        for (const fileOp of plan.highConfidence || []) {
            this.operationQueue.push({
                ...fileOp,
                priority: 'high',
                autoApprove: true,
                operation: 'copy'
            });
        }

        // ä¸­ç½®ä¿¡åº¦æ–‡ä»¶ - éœ€è¦ç¡®è®¤æˆ–è‡ªåŠ¨å¤„ç†
        for (const fileOp of plan.mediumConfidence || []) {
            this.operationQueue.push({
                ...fileOp,
                priority: 'medium',
                autoApprove: this.config.autoApproveMedium || false,
                operation: 'copy'
            });
        }

        // æ‰‹åŠ¨å®¡æŸ¥ç»“æœ - æŒ‰å®¡æŸ¥å†³å®šå¤„ç†
        for (const fileOp of plan.manualReview || []) {
            if (fileOp.decision === 'approve' || fileOp.decision === 'modify') {
                this.operationQueue.push({
                    ...fileOp,
                    priority: 'reviewed',
                    autoApprove: true,
                    operation: 'copy'
                });
            }
        }

        // æŒ‰ä¼˜å…ˆçº§æ’åº
        this.operationQueue.sort((a, b) => {
            const priorityOrder = { 'high': 0, 'reviewed': 1, 'medium': 2 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
        });

        console.log(`æ“ä½œé˜Ÿåˆ—æ„å»ºå®Œæˆ: ${this.operationQueue.length} ä¸ªæ“ä½œ`);
    }

    async performPreflightChecks() {
        console.log('æ‰§è¡Œé¢„æ£€æŸ¥...');

        const checks = {
            diskSpace: await this.checkDiskSpace(),
            permissions: await this.checkPermissions(),
            conflicts: await this.checkFileConflicts(),
            dependencies: await this.checkDependencies()
        };

        console.log('é¢„æ£€æŸ¥ç»“æœ:');
        console.log(`- ç£ç›˜ç©ºé—´: ${checks.diskSpace ? 'é€šè¿‡' : 'è­¦å‘Š'}`);
        console.log(`- æƒé™æ£€æŸ¥: ${checks.permissions ? 'é€šè¿‡' : 'å¤±è´¥'}`);
        console.log(`- å†²çªæ£€æŸ¥: ${checks.conflicts.length} ä¸ªæ½œåœ¨å†²çª`);
        console.log(`- ä¾èµ–æ£€æŸ¥: ${checks.dependencies ? 'é€šè¿‡' : 'è­¦å‘Š'}`);

        if (!checks.permissions) {
            throw new Error('æƒé™æ£€æŸ¥å¤±è´¥ï¼Œæ— æ³•ç»§ç»­æ¢å¤æ“ä½œ');
        }

        if (checks.conflicts.length > 0) {
            await this.handleConflicts(checks.conflicts);
        }

        return checks;
    }

    async checkDiskSpace() {
        try {
            const stats = fs.statSync(this.config.targetDir);
            // ç®€å•çš„ç£ç›˜ç©ºé—´æ£€æŸ¥ - å®é™…å®ç°å¯èƒ½éœ€è¦æ›´å¤æ‚çš„é€»è¾‘
            return true;
        } catch (error) {
            console.warn('ç£ç›˜ç©ºé—´æ£€æŸ¥å¤±è´¥:', error.message);
            return false;
        }
    }

    async checkPermissions() {
        try {
            // æµ‹è¯•å†™æƒé™
            const testFile = path.join(this.config.targetDir, '.recovery-test');
            fs.writeFileSync(testFile, 'test');
            fs.unlinkSync(testFile);
            return true;
        } catch (error) {
            console.error('æƒé™æ£€æŸ¥å¤±è´¥:', error.message);
            return false;
        }
    }

    async checkFileConflicts() {
        const conflicts = [];

        for (const operation of this.operationQueue) {
            const targetPath = path.resolve(this.config.targetDir, operation.targetFile);

            if (fs.existsSync(targetPath)) {
                conflicts.push({
                    operation,
                    targetPath,
                    existingFile: true
                });
            }
        }

        return conflicts;
    }

    async checkDependencies() {
        // æ£€æŸ¥æ–‡ä»¶ä¹‹é—´çš„ä¾èµ–å…³ç³»
        // è¿™é‡Œæ˜¯ç®€åŒ–ç‰ˆæœ¬ï¼Œå®é™…å®ç°å¯èƒ½éœ€è¦è§£æimportè¯­å¥
        return true;
    }

    async handleConflicts(conflicts) {
        console.log(`å¤„ç† ${conflicts.length} ä¸ªæ–‡ä»¶å†²çª...`);

        for (const conflict of conflicts) {
            const resolution = await this.resolveConflict(conflict);

            switch (resolution) {
                case 'overwrite':
                    // ç»§ç»­æ“ä½œï¼Œå°†è¦†ç›–ç°æœ‰æ–‡ä»¶
                    break;
                case 'skip':
                    this.recoveryState.skipped.push({
                        operation: conflict.operation,
                        reason: 'User chose to skip due to conflict'
                    });
                    // ä»æ“ä½œé˜Ÿåˆ—ä¸­ç§»é™¤
                    this.operationQueue = this.operationQueue.filter(op => op !== conflict.operation);
                    break;
                case 'version':
                    // ä¿®æ”¹ç›®æ ‡æ–‡ä»¶åä»¥é¿å…å†²çª
                    conflict.operation.targetFile = this.generateVersionedName(conflict.operation.targetFile);
                    break;
                case 'backup':
                    // å¤‡ä»½ç°æœ‰æ–‡ä»¶ç„¶åè¦†ç›–
                    await this.backupExistingFile(conflict.targetPath);
                    break;
            }
        }
    }

    async resolveConflict(conflict) {
        // æ ¹æ®é…ç½®å†³å®šå†²çªå¤„ç†ç­–ç•¥
        switch (this.config.overwritePolicy) {
            case 'overwrite':
                return 'overwrite';
            case 'skip':
                return 'skip';
            case 'version':
                return 'version';
            case 'backup':
                return 'backup';
            case 'prompt':
            default:
                // åœ¨éäº¤äº’ç¯å¢ƒä¸­ï¼Œé»˜è®¤ä½¿ç”¨ç‰ˆæœ¬ç­–ç•¥
                return 'version';
        }
    }

    generateVersionedName(filename) {
        const ext = path.extname(filename);
        const base = path.basename(filename, ext);
        const dir = path.dirname(filename);

        let counter = 1;
        let versionedName;

        do {
            versionedName = path.join(dir, `${base}_v${counter}${ext}`);
            counter++;
        } while (fs.existsSync(path.resolve(this.config.targetDir, versionedName)));

        return versionedName;
    }

    async backupExistingFile(targetPath) {
        const backupName = `${path.basename(targetPath)}.backup.${Date.now()}`;
        const backupPath = path.join(this.config.backupDir, backupName);

        fs.copyFileSync(targetPath, backupPath);
        this.recoveryState.backups.push({
            original: targetPath,
            backup: backupPath,
            timestamp: new Date()
        });

        console.log(`å¤‡ä»½æ–‡ä»¶: ${targetPath} -> ${backupPath}`);
    }

    async executeOperations() {
        console.log('æ‰§è¡Œæ¢å¤æ“ä½œ...');

        for (let i = 0; i < this.operationQueue.length; i++) {
            const operation = this.operationQueue[i];
            console.log(`[${i + 1}/${this.operationQueue.length}] å¤„ç†: ${operation.sourceFile} -> ${operation.targetFile}`);

            try {
                await this.executeOperation(operation);
                this.recoveryState.successful.push({
                    operation,
                    timestamp: new Date()
                });
            } catch (error) {
                console.error(`æ“ä½œå¤±è´¥: ${operation.sourceFile}`, error.message);
                this.recoveryState.failed.push({
                    operation,
                    error: error.message,
                    timestamp: new Date()
                });

                // æ ¹æ®é…ç½®å†³å®šæ˜¯å¦ç»§ç»­
                if (this.config.stopOnError) {
                    throw new Error(`æ“ä½œå¤±è´¥ï¼Œåœæ­¢æ¢å¤: ${error.message}`);
                }
            }
        }

        console.log(`æ¢å¤æ“ä½œå®Œæˆ: ${this.recoveryState.successful.length} æˆåŠŸ, ${this.recoveryState.failed.length} å¤±è´¥`);
    }

    async executeOperation(operation) {
        const sourcePath = path.resolve(this.config.sourceDir, operation.sourceFile);
        const targetPath = path.resolve(this.config.targetDir, operation.targetFile);

        // ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
        fs.mkdirSync(path.dirname(targetPath), { recursive: true });

        if (this.config.dryRun) {
            console.log(`[DRY RUN] å°†å¤åˆ¶: ${sourcePath} -> ${targetPath}`);
            return;
        }

        // è®¡ç®—æºæ–‡ä»¶æ ¡éªŒå’Œ
        if (this.config.verifyChecksums) {
            const sourceChecksum = await this.calculateChecksum(sourcePath);
            this.recoveryState.checksums.set(operation.sourceFile, sourceChecksum);
        }

        // æ‰§è¡Œæ–‡ä»¶æ“ä½œ
        switch (operation.operation) {
            case 'copy':
                fs.copyFileSync(sourcePath, targetPath);
                break;
            case 'move':
                fs.renameSync(sourcePath, targetPath);
                break;
            default:
                throw new Error(`ä¸æ”¯æŒçš„æ“ä½œç±»å‹: ${operation.operation}`);
        }

        // éªŒè¯æ“ä½œç»“æœ
        if (this.config.verifyChecksums) {
            const targetChecksum = await this.calculateChecksum(targetPath);
            const sourceChecksum = this.recoveryState.checksums.get(operation.sourceFile);

            if (sourceChecksum !== targetChecksum) {
                throw new Error(`æ ¡éªŒå’Œä¸åŒ¹é…: ${operation.sourceFile}`);
            }
        }

        // è®¾ç½®æ–‡ä»¶æƒé™ï¼ˆå¦‚æœæŒ‡å®šï¼‰
        if (operation.permissions) {
            fs.chmodSync(targetPath, operation.permissions);
        }
    }

    async calculateChecksum(filePath) {
        return new Promise((resolve, reject) => {
            const hash = crypto.createHash('sha256');
            const stream = fs.createReadStream(filePath);

            stream.on('data', data => hash.update(data));
            stream.on('end', () => resolve(hash.digest('hex')));
            stream.on('error', reject);
        });
    }

    async verifyRecoveryResults() {
        console.log('éªŒè¯æ¢å¤ç»“æœ...');

        const verificationResults = {
            filesExist: 0,
            checksumMatches: 0,
            totalFiles: this.recoveryState.successful.length
        };

        for (const success of this.recoveryState.successful) {
            const targetPath = path.resolve(this.config.targetDir, success.operation.targetFile);

            // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
            if (fs.existsSync(targetPath)) {
                verificationResults.filesExist++;

                // éªŒè¯æ ¡éªŒå’Œ
                if (this.config.verifyChecksums) {
                    const targetChecksum = await this.calculateChecksum(targetPath);
                    const sourceChecksum = this.recoveryState.checksums.get(success.operation.sourceFile);

                    if (targetChecksum === sourceChecksum) {
                        verificationResults.checksumMatches++;
                    }
                }
            }
        }

        console.log('éªŒè¯ç»“æœ:');
        console.log(`- æ–‡ä»¶å­˜åœ¨: ${verificationResults.filesExist}/${verificationResults.totalFiles}`);
        if (this.config.verifyChecksums) {
            console.log(`- æ ¡éªŒå’ŒåŒ¹é…: ${verificationResults.checksumMatches}/${verificationResults.totalFiles}`);
        }

        this.recoveryState.verificationResults = verificationResults;
        return verificationResults;
    }

    async generateRecoveryReport() {
        console.log('ç”Ÿæˆæ¢å¤æŠ¥å‘Š...');

        const report = {
            summary: {
                startTime: this.recoveryState.startTime,
                endTime: this.recoveryState.endTime,
                duration: this.recoveryState.endTime - this.recoveryState.startTime,
                totalOperations: this.operationQueue.length,
                successful: this.recoveryState.successful.length,
                failed: this.recoveryState.failed.length,
                skipped: this.recoveryState.skipped.length,
                conflicts: this.recoveryState.conflicts.length,
                backups: this.recoveryState.backups.length
            },
            configuration: this.config,
            results: this.recoveryState,
            recommendations: this.generateRecommendations()
        };

        // ä¿å­˜è¯¦ç»†æŠ¥å‘Š
        const reportPath = path.join(path.dirname(this.config.sourceDir), 'recovery-report.json');
        fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));

        // ç”Ÿæˆäººç±»å¯è¯»æŠ¥å‘Š
        await this.generateHumanReadableReport(report);

        console.log('æ¢å¤æŠ¥å‘Šç”Ÿæˆå®Œæˆ');
        return report;
    }

    async generateHumanReadableReport(report) {
        let output = '# ğŸ”„ å®‰å…¨æ¢å¤ç³»ç»ŸæŠ¥å‘Š\n\n';

        output += `**æ¢å¤æ—¶é—´**: ${report.summary.startTime.toLocaleString()} - ${report.summary.endTime.toLocaleString()}\n`;
        output += `**è€—æ—¶**: ${Math.round(report.summary.duration / 1000)} ç§’\n\n`;

        output += '## ğŸ“Š æ¢å¤ç»Ÿè®¡\n';
        output += `- âœ… æˆåŠŸ: ${report.summary.successful} ä¸ªæ–‡ä»¶\n`;
        output += `- âŒ å¤±è´¥: ${report.summary.failed} ä¸ªæ–‡ä»¶\n`;
        output += `- â­ï¸ è·³è¿‡: ${report.summary.skipped} ä¸ªæ–‡ä»¶\n`;
        output += `- ğŸ”„ å¤‡ä»½: ${report.summary.backups} ä¸ªæ–‡ä»¶\n`;
        output += `- ğŸ“ˆ æˆåŠŸç‡: ${((report.summary.successful / report.summary.totalOperations) * 100).toFixed(1)}%\n\n`;

        // æˆåŠŸçš„æ“ä½œ
        if (this.recoveryState.successful.length > 0) {
            output += '## âœ… æˆåŠŸæ¢å¤çš„æ–‡ä»¶\n';
            this.recoveryState.successful.forEach(item => {
                output += `- **${item.operation.sourceFile}** â†’ \`${item.operation.targetFile}\`\n`;
            });
            output += '\n';
        }

        // å¤±è´¥çš„æ“ä½œ
        if (this.recoveryState.failed.length > 0) {
            output += '## âŒ æ¢å¤å¤±è´¥çš„æ–‡ä»¶\n';
            this.recoveryState.failed.forEach(item => {
                output += `- **${item.operation.sourceFile}**: ${item.error}\n`;
            });
            output += '\n';
        }

        // æ¨èæ“ä½œ
        output += '## ğŸš€ æ¨èçš„åç»­æ“ä½œ\n';
        report.recommendations.forEach((rec, i) => {
            output += `${i + 1}. **${rec.action}**: ${rec.message}\n`;
        });

        const reportPath = path.join(path.dirname(this.config.sourceDir), 'RECOVERY_REPORT.md');
        fs.writeFileSync(reportPath, output);
    }

    generateRecommendations() {
        const recommendations = [];

        if (this.recoveryState.successful.length > 0) {
            recommendations.push({
                priority: 'high',
                action: 'test_project',
                message: `æµ‹è¯•é¡¹ç›®æ„å»ºå’Œè¿è¡Œï¼Œç¡®ä¿ ${this.recoveryState.successful.length} ä¸ªæ¢å¤çš„æ–‡ä»¶æ­£å¸¸å·¥ä½œ`
            });
        }

        if (this.recoveryState.failed.length > 0) {
            recommendations.push({
                priority: 'high',
                action: 'handle_failures',
                message: `æ‰‹åŠ¨å¤„ç† ${this.recoveryState.failed.length} ä¸ªæ¢å¤å¤±è´¥çš„æ–‡ä»¶`
            });
        }

        if (this.recoveryState.backups.length > 0) {
            recommendations.push({
                priority: 'medium',
                action: 'review_backups',
                message: `å®¡æŸ¥ ${this.recoveryState.backups.length} ä¸ªå¤‡ä»½æ–‡ä»¶ï¼Œç¡®è®¤æ˜¯å¦éœ€è¦ä¿ç•™`
            });
        }

        if (this.recoveryState.skipped.length > 0) {
            recommendations.push({
                priority: 'low',
                action: 'review_skipped',
                message: `è€ƒè™‘é‡æ–°å¤„ç† ${this.recoveryState.skipped.length} ä¸ªè¢«è·³è¿‡çš„æ–‡ä»¶`
            });
        }

        return recommendations;
    }

    async handleRecoveryFailure(error) {
        console.log('å¤„ç†æ¢å¤å¤±è´¥...');

        // è®°å½•é”™è¯¯çŠ¶æ€
        this.recoveryState.endTime = new Date();
        this.recoveryState.error = error.message;

        // ç”Ÿæˆå¤±è´¥æŠ¥å‘Š
        await this.generateRecoveryReport();

        // å¦‚æœéœ€è¦ï¼Œæ‰§è¡Œå›æ»šæ“ä½œ
        if (this.config.rollbackOnFailure) {
            await this.rollbackChanges();
        }
    }

    async rollbackChanges() {
        console.log('æ‰§è¡Œå›æ»šæ“ä½œ...');

        for (const success of this.recoveryState.successful) {
            try {
                const targetPath = path.resolve(this.config.targetDir, success.operation.targetFile);
                if (fs.existsSync(targetPath)) {
                    fs.unlinkSync(targetPath);
                    console.log(`å›æ»š: åˆ é™¤ ${targetPath}`);
                }
            } catch (error) {
                console.error(`å›æ»šå¤±è´¥: ${success.operation.targetFile}`, error.message);
            }
        }

        // æ¢å¤å¤‡ä»½æ–‡ä»¶
        for (const backup of this.recoveryState.backups) {
            try {
                fs.copyFileSync(backup.backup, backup.original);
                console.log(`æ¢å¤å¤‡ä»½: ${backup.backup} -> ${backup.original}`);
            } catch (error) {
                console.error(`å¤‡ä»½æ¢å¤å¤±è´¥: ${backup.original}`, error.message);
            }
        }
    }

    // é™æ€å·¥å‚æ–¹æ³•
    static createFromConfig(configPath) {
        const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        return new SafeRecoverySystem(config);
    }

    static createFromPlans(highConfidencePlan, manualReviewResults, mediumConfidencePlan = []) {
        const recovery = new SafeRecoverySystem();

        const plan = {
            highConfidence: highConfidencePlan || [],
            mediumConfidence: mediumConfidencePlan || [],
            manualReview: manualReviewResults || []
        };

        return { recovery, plan };
    }
}

// ä½¿ç”¨ç¤ºä¾‹
async function main() {
    try {
        // ç¤ºä¾‹é…ç½®
        const config = {
            sourceDir: './classified',
            targetDir: '../recovered',
            backupDir: './recovery-backups',
            dryRun: false,
            verifyChecksums: true,
            createBackups: true,
            overwritePolicy: 'version'
        };

        const recovery = new SafeRecoverySystem(config);

        // ç¤ºä¾‹æ¢å¤è®¡åˆ’
        const plan = {
            highConfidence: [
                {
                    sourceFile: 'middleware/middleware.ts',
                    targetFile: 'middleware.ts',
                    confidence: 0.95
                }
            ],
            mediumConfidence: [
                {
                    sourceFile: 'config/next.config.js',
                    targetFile: 'next.config.js',
                    confidence: 0.75
                }
            ],
            manualReview: [
                {
                    sourceFile: 'components/Header.jsx',
                    targetFile: 'components/Header.jsx',
                    decision: 'approve',
                    confidence: 0.85
                }
            ]
        };

        const results = await recovery.executeRecovery(plan);

        console.log('æ¢å¤å®Œæˆï¼');
        console.log(`æˆåŠŸ: ${results.successful.length}, å¤±è´¥: ${results.failed.length}`);

    } catch (error) {
        console.error('æ¢å¤å¤±è´¥:', error.message);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}

module.exports = SafeRecoverySystem;



ä»»åŠ¡6ï¼šæ‰‹åŠ¨å®¡æŸ¥ç•Œé¢ç³»ç»Ÿå·²å®Œæˆã€‚æ‚¨æ„å»ºäº†ä¸€ä¸ªåŠŸèƒ½å®Œå¤‡çš„å®¡æŸ¥ç³»ç»Ÿï¼ŒåŒ…æ‹¬ï¼š

- äº¤äº’å¼é€æ–‡ä»¶å®¡æŸ¥ç•Œé¢
- æ‰¹é‡å¤„ç†é€‰é¡¹
- å®Œæ•´çš„æµ‹è¯•å’Œæ¼”ç¤ºç³»ç»Ÿ
- è¯¦ç»†çš„æ–‡æ¡£å’Œä½¿ç”¨æŒ‡å—

æ ¹æ®æˆ‘ä»¬çš„ä¸“ä¸šä¼˜å…ˆçº§åˆ†æï¼Œç°åœ¨åº”è¯¥ç»§ç»­æ‰§è¡Œä»»åŠ¡7ï¼šå®‰å…¨æ¢å¤ç³»ç»Ÿã€‚è¿™æ˜¯æ‰§è¡Œå±‚çš„å…³é”®ç»„ä»¶ï¼Œå°†å®é™…æ‰§è¡Œæ–‡ä»¶æ¢å¤æ“ä½œã€‚

è®©æˆ‘åˆ›å»ºä»»åŠ¡7çš„å®‰å…¨æ¢å¤ç³»ç»Ÿï¼š**ä»»åŠ¡7ï¼šå®‰å…¨æ¢å¤ç³»ç»Ÿå·²å®Œæˆ**

è¿™ä¸ªç³»ç»Ÿæä¾›äº†ä¼ä¸šçº§çš„æ–‡ä»¶æ¢å¤åŠŸèƒ½ï¼š

### æ ¸å¿ƒç‰¹æ€§
- **å…­é˜¶æ®µæ¢å¤æµç¨‹**: éªŒè¯ â†’ æ„å»ºé˜Ÿåˆ— â†’ é¢„æ£€æŸ¥ â†’ æ‰§è¡Œ â†’ éªŒè¯ â†’ æŠ¥å‘Š
- **å¤šé‡å®‰å…¨ä¿éšœ**: æ ¡éªŒå’ŒéªŒè¯ã€è‡ªåŠ¨å¤‡ä»½ã€å†²çªæ£€æµ‹ã€æƒé™æ£€æŸ¥
- **çµæ´»é…ç½®**: æ”¯æŒå¹²è¿è¡Œã€è¦†ç›–ç­–ç•¥ã€é”™è¯¯å¤„ç†ç­‰é€‰é¡¹
- **å®Œæ•´å®¡è®¡**: è¯¦ç»†çš„æ“ä½œæ—¥å¿—å’Œæ¢å¤æŠ¥å‘Š

### å®‰å…¨æœºåˆ¶
- **é¢„æ£€æŸ¥ç³»ç»Ÿ**: ç£ç›˜ç©ºé—´ã€æƒé™ã€å†²çªã€ä¾èµ–å…³ç³»æ£€æŸ¥
- **å†²çªå¤„ç†**: å››ç§ç­–ç•¥ï¼ˆè¦†ç›–ã€è·³è¿‡ã€ç‰ˆæœ¬åŒ–ã€å¤‡ä»½ï¼‰
- **é”™è¯¯æ¢å¤**: æ”¯æŒå›æ»šæ“ä½œå’Œå¤±è´¥å¤„ç†
- **æ•°æ®å®Œæ•´æ€§**: SHA256æ ¡éªŒå’ŒéªŒè¯

### ä½¿ç”¨æ–¹æ³•
```javascript
const recovery = new SafeRecoverySystem({
    sourceDir: './classified',
    targetDir: '../recovered',
    dryRun: false,
    verifyChecksums: true
});

await recovery.executeRecovery(recoveryPlan);
```

æ ¹æ®æˆ‘ä»¬çš„ä¸“ä¸šä¼˜å…ˆçº§åˆ†æï¼Œç°åœ¨åº”è¯¥ç»§ç»­æ‰§è¡Œä»»åŠ¡8ï¼šæ„å»ºæ—¥å¿—å’ŒæŠ¥å‘Šç³»ç»Ÿã€‚è¿™æ˜¯è´¨é‡ä¿è¯å’Œé—®é¢˜æ’æŸ¥çš„å…³é”®åŸºç¡€è®¾æ–½ã€‚

æ‚¨æƒ³ç»§ç»­ä»»åŠ¡8ï¼Œè¿˜æ˜¯å…ˆæµ‹è¯•å½“å‰å·²å®Œæˆçš„ç³»ç»Ÿï¼Ÿ
